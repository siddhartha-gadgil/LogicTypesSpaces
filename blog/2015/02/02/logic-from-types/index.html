
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Logic From Types - Logic, Types and Spaces</title>
  <meta name="author" content="Siddhartha Gadgil">

  
  <meta name="description" content="At the core of homotopy type theory (and its predecessors) is the idea of propostions as types. Namely, we interpret logical propositions - &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://siddhartha-gadgil.github.io//github/blog/2015/02/02/logic-from-types">
  <link href="/LogicTypesSpaces/favicon.png" rel="icon">
  <link href="/LogicTypesSpaces/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Logic, Types and Spaces" type="application/atom+xml">
  <script src="/LogicTypesSpaces/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/LogicTypesSpaces/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-58114020-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="/LogicTypesSpaces/">Logic, Types and Spaces</a></h1>
  
    <h2>Towards homotopy type theory</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:siddhartha-gadgil.github.io//github" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/LogicTypesSpaces/home">Home</a></li>
  <li><a href="/LogicTypesSpaces/">Blog</a></li>
  <li><a href="/LogicTypesSpaces/blog/archives">Archives</a></li>
  <li><a href="/LogicTypesSpaces/blog/categories/exercises/">Exercises</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Logic From Types</h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


<div class="entry-content"><p>At the core of homotopy type theory (and its predecessors) is the idea of <em>propostions as types</em>. Namely, we interpret logical <em>propositions</em> - statements that are either true or false, as <em>types</em>, with a <em>term</em> having a given type being viewed as a <em>proof</em> of the corresponding proposition. The Curry-Howard correspondence lets us embed all of logic into type theory in the manner.</p>

<h3 id="true-and-false">True and False</h3>

<p>We begin by representing the two simplest propositions: true - always true,  and false.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>True and False types</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">True</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">qed</span> <span class="kt">:</span> <span class="kt">True</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="kr">data</span> <span class="kt">False</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The $True$ type has just one constructor, giving an object with type $True$. On the other hand, the $False$ type has no constructors, so there are no objects of type $False$.</p>

<p>There are various ways of building propositions from other propositions. We see how these translate to constructions of types.</p>

<h3 id="logical-implies">Logical implies</h3>

<p>If $P$ and $Q$ are propositions, which we identify with their corresponding types. We interpret the proposition $P \implies Q$ as the function type $P \to Q$.</p>

<h3 id="some-deductions">Some deductions</h3>

<p><em>Modus Ponens</em> is the rule of deduction (going back to antiquity) that says that if the proposition $P$ is true, and $P$ implies $Q$, then $Q$ is true. We can prove this in the types interpretation. Namely, Modus Ponens translates to the statement that if we have an objects of type $P$ and $P \to Q$, then we have an object of type $Q$. We get an object of type $Q$ by function application.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">mp</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">P</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="kt">Q</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">P</span> <span class="err">→</span> <span class="p">(</span><span class="kt">P</span> <span class="err">→</span> <span class="kt">Q</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Q</span>
</span><span class="line"><span class="nf">mp</span> <span class="n">p</span> <span class="n">imp</span> <span class="ow">=</span> <span class="n">imp</span> <span class="n">p</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Next, we see my favourite method of proof - vacuous implication. This says that a false statement implies everything, i.e., for any proposition $P$, we have $False \implies P$, which in type theory says $False\to P$ has objects.</p>

<p>As the $False$ type has no cases at all, a function is defined on $False$ by using an absurd pattern, which just says that there are no cases, so no definition is needed.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">vacuous</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">False</span> <span class="err">→</span> <span class="kt">A</span>
</span><span class="line"><span class="nf">vacuous</span> <span class="nb">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Formally, as the $False$ type has no constructors, the recursion function $rec_{False, A}$ has type $False \to A$. We simply take this as the vacuous implication.</p>

<h3 id="even-and-odd-numbers">Even and Odd numbers</h3>

<p>Next, we define a type family $Even(n)$, for $n : \mathbb{N}$, which is non-empty if and only if $n$ is even. To do this, we see that a number is even if and only if it is even as a consequence of the rules</p>

<ul>
  <li>$0$ is even.</li>
  <li>If $n$ is even, so is $n + 2$.</li>
</ul>

<p>Thus, we can define the inductive type family:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Even</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="mi">0</span><span class="n">even</span> <span class="kt">:</span> <span class="kt">Even</span> <span class="mi">0</span>
</span><span class="line">  <span class="kr">_</span><span class="o">+</span><span class="mi">2</span><span class="n">even</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Even</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Even</span> <span class="p">(</span><span class="n">succ</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can prove that $4$ is even by applying the second constructor to the first constructor (telling us that $0$ is even) twice.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="mi">4</span><span class="n">even</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">0</span><span class="n">even</span> <span class="o">+</span><span class="mi">2</span><span class="n">even</span><span class="p">)</span> <span class="o">+</span><span class="mi">2</span><span class="n">even</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We next show that $1$ is odd. This means that we have to show that the type $Even\ 1$ is empty. While rules let us construct objects, and verify their types, there is no rule that tells us directly that a type is empty.</p>

<p>However, there is a nice way of capturing that a type $A$ is empty - if there is a function from $A$ to the empty type $False$, then $A$ must be empty - there is nowhere for an object of type $A$ to be mapped.</p>

<p>Indeed, what we prove is that there is a function from $Even\ 1$ to $False$ ; we define this using an absurd pattern.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>1 is odd</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="mi">1</span><span class="n">odd</span> <span class="kt">:</span> <span class="kt">Even</span> <span class="mi">1</span> <span class="err">→</span> <span class="kt">False</span>
</span><span class="line"><span class="mi">1</span><span class="n">odd</span> <span class="nb">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This can be formalized by defining a dependent function on the inductive type family $Even$ with appropriate type.</p>

<h3 id="more-types-for-propositions">More types for propositions</h3>

<p>We now see the types corresponding to other ways of combining propositions: logical operations <em>and</em> and <em>or</em>.</p>

<p>Firstly, if $A$ and $B$ are types corresponding to propositions, then there are objects with each of these types if and only if there is a pair $(a, b)$ of the pair type $A \times B$.</p>

<p>Next, suppose $A$ and $B$ are types corresponding to propositions and we wish to construct a type corresponding to $A$ <em>or</em> $B$, then we require a type whose elements are elements of $A$ and elements of $B$, or more accurately the images of such elements under constructors. This is the direct sum type.</p>

<p>The above methods let us combine propositions without quantifiers in all the logical ways. In doing so we used type theory, but not dependent types. Dependent types also let us express logical statements with quantifiers.</p>

<h3 id="for-all">For all</h3>

<p>Suppose we have a type $A$ and a family of types $P(a)$ (which we regard as propositions), with a type associated to each object $a$ of type $A$. Then all the types $P(a)$ have objects  (i.e., all corresponding propositions are true) if and only if there is a dependent function mapping each object $a$ of type $A$ to an object of type  $P(a)$. Thus, the logical statement</p>

<script type="math/tex; mode=display">\forall a \in A\ P(a)</script>

<p>translates to the product type</p>

<script type="math/tex; mode=display">\prod\limits_{a : A} P(a).</script>

<p>As we have seen, in Agda we represent the product type as $(a : A) \to P(a)$</p>

<h3 id="exists">Exists</h3>

<p>Next, if we are given a collection of types $B(a)$ for objects $a$ of type $A$, the type corresponding to at least one of these types having an element is a $\Sigma$-type, as there is an element of $B(a)$ for at least one $a : A$ if and only if there is a pair term $(a, b)$ with $b : B(a)$.</p>

<h2 id="a-proof-by-induction">A proof by induction</h2>

<p>If $n$ is a natural number, we can prove by induction that one of $n$ and $n+1$ is even. We shall prove this in its  type theoretic form. We will do this in an Agda module to keep notation clean - the module consists of all the tab spaced lines following its definition. In the following code, we define the property that for all $n$, one of $n$ and $n+1$ is even as $P$ (in a submodule). We then prove the induction step and use  it to prove  the  theorem.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">module</span> <span class="err">n|n+1even</span> <span class="err">where</span>
</span><span class="line">  <span class="nn">P</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Type</span>
</span><span class="line">  <span class="kt">P</span> <span class="n">n</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Even</span> <span class="n">n</span><span class="p">)</span> <span class="err">⊕</span> <span class="p">(</span><span class="kt">Even</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">))</span>
</span><span class="line">
</span><span class="line">  <span class="n">step</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">P</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line">  <span class="n">step</span> <span class="p">(</span><span class="err">ι₁</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="err">ι₂</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span><span class="mi">2</span><span class="n">even</span><span class="p">)</span>
</span><span class="line">  <span class="n">step</span> <span class="p">(</span><span class="err">ι₂</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="err">ι₁</span> <span class="n">p</span>
</span><span class="line">
</span><span class="line">  <span class="n">thm</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span>
</span><span class="line">  <span class="n">thm</span> <span class="mi">0</span> <span class="ow">=</span> <span class="err">ι₁</span> <span class="mi">0</span><span class="n">even</span>
</span><span class="line">  <span class="n">thm</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">step</span> <span class="p">(</span><span class="n">thm</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The definition is just a translation of the logical or into dependent sums and of $\forall$ into dependent functions.</p>

<p>In the induction step, we assume that we have a proof for $n$. Thus $n$ and the corresponding proof are arguments, but $n$ can be inferred. There are two cases - if we have a proof that $n$ is even (i.e., the first alternative  for $P(n)$), we obtain a proof that $n+2 = (n+1) + 1$ is even by using the  rule $\_+2even$, which is the second alternative for the statement $P(n+1)$. In the case where  $n + 1$ is  even, we directly obtain the first  alternative for $P(n+1)$.</p>

<p>The theorem itself is simply obtained by putting together the base case and the induction step.</p>

<p>This proof is remarkable in many ways. First of all, note that this is no longer or more complicated than an informal proof. Further, note that we did not have to invoke the usual induction axiom schema, but instead just used the rules for constructing objects. Most significantly, as most of our types are inductive type (or type families), we get recursive definitions and inductive proofs in all these cases.</p>

<p>Indeed,  using recursive definitions for inductive types we get all so called <em>universal properties</em>. Furthermore, traditionally universal properties require a separate uniqueness statement. But recursion-induction is powerful enough to even give the uniqueness statements for universal properties. This means a great deal of mathematical sophistication (universal algebra, various aspects of category theory) are encapsulated in these simple functions.</p>

<h2 id="functions-with-conditions-and-certificates">Functions with conditions and certificates.</h2>

<p>Often functions are meant to be defined only when some conditions are satisfied, for instance we may  wish to define a function $half : \mathbb{N} \to \mathbb{N}$ only for even integers. Traditionally, the way to deal with this situation is either to check the conditions, and declare an error (“throw an exception”) if they fail, or return some (incorrect) value if the condition fails perhaps causing serious errors elsewhere.</p>

<p>With propositions as types, there is a better alternative - the function can require, as an additional argument, a <em>proof</em> that a condition is satisfied. For instance, here is such a function.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">half</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Even</span> <span class="n">n</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">half</span> <span class="o">.</span><span class="mi">0</span> <span class="mi">0</span><span class="n">even</span> <span class="ow">=</span> <span class="mi">0</span>
</span><span class="line"><span class="nf">half</span> <span class="p">(</span><span class="n">succ</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">))</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span><span class="mi">2</span><span class="n">even</span><span class="p">)</span> <span class="ow">=</span> <span class="n">succ</span> <span class="p">(</span><span class="n">half</span> <span class="n">n</span> <span class="n">p</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Our definition also illustrates Agda’s <em>dot</em> notation. The first argument in the first case being <strong>.0</strong> means that we can infer from types that its value must be zero.</p>

<p>Note that in the second case we must have a pattern of the form $succ(succ (n))$, from which it can be deduced that $p$ has type $Even n$. If we just tried to match to $n$, then we cannot in general reconcile the terms and types.</p>

<p>We may also wish to assert that the result of functions have some additional property - for instance that a function returns a <em>sorted</em> list. This is best achieved if the value of the function includes a proof that the condition holds. For example, the following function doubles a number and also gives evidence that it is even.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">double</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="err">Σ</span> <span class="err">ℕ</span> <span class="kt">Even</span>
</span><span class="line"><span class="nf">double</span> <span class="mi">0</span> <span class="ow">=</span> <span class="p">[</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">0</span><span class="n">even</span> <span class="p">]</span>
</span><span class="line"><span class="nf">double</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">succ</span> <span class="p">(</span><span class="n">succ</span> <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="p">(</span><span class="n">double</span> <span class="n">n</span><span class="p">))))</span> <span class="p">,</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="p">(</span><span class="n">double</span> <span class="n">n</span><span class="p">))</span> <span class="o">+</span><span class="mi">2</span><span class="n">even</span> <span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can use the proof provided by such a function to apply a function that requires a proof.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">halfdouble</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">halfdouble</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">half</span> <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="p">(</span><span class="n">double</span> <span class="n">n</span><span class="p">))</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="p">(</span><span class="n">double</span> <span class="n">n</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="the-collatz-function">The Collatz function.</h3>

<p>As a more complex example, we construct the  function governing the <a href="http://en.wikipedia.org/wiki/Collatz_conjecture">Collatz conjecture</a>, which maps a natural number  $n$ to $n/2$ if $n$ is even, and $3n + 1$ if $n$ is odd, or equivalently $n+1$ is even. We use our halving function  with proof, and the proof that one of $n$ and $n+1$ is even.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">module</span> <span class="nn">Collatz</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">frompf</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="n">n</span><span class="o">|</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="n">even</span><span class="o">.</span><span class="kt">P</span> <span class="n">n</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line">  <span class="n">frompf</span> <span class="n">n</span> <span class="p">(</span><span class="err">ι₁</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">half</span> <span class="n">n</span> <span class="n">p</span>
</span><span class="line">  <span class="n">frompf</span> <span class="n">n</span> <span class="p">(</span><span class="err">ι₂</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line">  <span class="n">fn</span> <span class="ow">=</span> <span class="err">λ</span> <span class="n">n</span> <span class="err">→</span> <span class="n">frompf</span> <span class="n">n</span> <span class="p">(</span><span class="n">n</span><span class="o">|</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="n">even</span><span class="o">.</span><span class="n">thm</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Note that we access a term <em>T</em> in the module <em>n|n+1even</em> from outside the module by prefacing it with <em>n|n+1even.</em> to get <em>n|n+1even.T</em>.</p>

<h3 id="the-identity-type">The identity type</h3>

<p>One of the most fundamental concepts in homotopy type theory is the identity type family, representing equality between objects with a given type. This is an inductive type family, generated by the reflexivity constructor giving an equality between an object and itself.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>The identity type</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kr">_</span><span class="o">==</span><span class="kr">_</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">refl</span> <span class="kt">:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="n">a</span> <span class="o">==</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Note that while this is an inductive type family, for a fixed object a the type $a==a$ is <em>not</em> an inductive type defined by $refl(a)$, i.e., we cannot define (dependent) functions on this type but just defining them on the reflexivity constructor. This is a subtle point, which will become clearer as we look at the topological interpretation. We shall study the identity type extensively.</p>

<p>For now, let us show some basic properties of the identity type. All these are proved by constructing proof terms by induction. These are in a separate module <strong>Id</strong>.</p>

<p>Firstly, we see that equality (given by the identity type) is symmetric and transitive. Symmetry is straightforward.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">sym</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">x</span> <span class="n">y</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">}</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="err">→</span> <span class="n">y</span> <span class="o">==</span> <span class="n">x</span>
</span><span class="line"><span class="nf">sym</span> <span class="p">(</span><span class="n">refl</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">refl</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Next, we see transitivity of equality, for which we use $\&amp;\&amp;$ as notation.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">_</span><span class="o">&amp;&amp;</span><span class="kr">_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">}</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="err">→</span> <span class="n">y</span> <span class="o">==</span> <span class="n">z</span>  <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">z</span>
</span><span class="line"><span class="kr">_</span><span class="o">&amp;&amp;</span><span class="kr">_</span> <span class="p">(</span><span class="n">refl</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">refl</span> <span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">refl</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We have once more used the <em>dot notation</em>. Notice that we have a term <strong>.a</strong> - this says that we can deduce, <em>from the types</em>, that $a$ is the only possibility at its position in the pattern.</p>

<p>If two terms are equal, then the terms resulting from applying a function to them are also equal. We prove this next.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">_</span><span class="o">#</span><span class="kr">_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">x</span> <span class="n">y</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span><span class="p">)</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">f</span> <span class="n">y</span><span class="p">)</span>
</span><span class="line"><span class="nf">f</span> <span class="o">#</span> <span class="p">(</span><span class="n">refl</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">refl</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>As we see, we can express all the usual mathematical statements using types built up using our basic constructions: inductive types, functions and dependent functions. We have also seen that the basic rules for constructing objects are powerful rules of deduction. However, there are some things they cannot deduce, for instance the statement (called the axiom of extensionality) that if $f, g: A\to B$ are function with $f(a)=g(a)$ for all $a \in A$, then $f=g$. Hence, we have to introduce this as a postulate - we just postulate that  there is an object (which we give a name) of a given type.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">postulate</span>
</span><span class="line">  <span class="n">extensionality</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">g</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span><span class="p">)</span> <span class="err">→</span> <span class="p">((</span><span class="n">x</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span> <span class="err">→</span> <span class="n">f</span> <span class="o">==</span> <span class="n">g</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can similarly introduce axioms specific to a domain, say Euclidean geometry, by postulating them in a module.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Siddhartha Gadgil</span></span>

      





      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://siddhartha-gadgil.github.io//github/blog/2015/02/02/logic-from-types/" data-via="" data-counturl="http://siddhartha-gadgil.github.io//github/blog/2015/02/02/logic-from-types/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/LogicTypesSpaces/blog/2015/01/30/fin-type-family/" title="Previous Post: Fin type family">&laquo; Fin type family</a>
      
      
        <a class="basic-alignment right" href="/LogicTypesSpaces/blog/2015/02/09/exercises-for-midterm/" title="Next Post: Exercises for midterm">Exercises for midterm &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/LogicTypesSpaces/blog/2015/02/09/exercises-for-midterm/">Exercises for Midterm</a>
      </li>
    
      <li class="post">
        <a href="/LogicTypesSpaces/blog/2015/02/02/logic-from-types/">Logic From Types</a>
      </li>
    
      <li class="post">
        <a href="/LogicTypesSpaces/blog/2015/01/30/fin-type-family/">Fin Type Family</a>
      </li>
    
      <li class="post">
        <a href="/LogicTypesSpaces/blog/2015/01/25/rooted-trees-and-general-induction/">Rooted Trees and General Induction</a>
      </li>
    
      <li class="post">
        <a href="/LogicTypesSpaces/blog/2015/01/23/constructing-dependent-functions/">Constructing Dependent Functions</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/siddhartha-gadgil">@siddhartha-gadgil</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'siddhartha-gadgil',
            count: 4,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/LogicTypesSpaces/javascripts/github.js" type="text/javascript"> </script>
</section>



<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/+SiddharthaGadgil?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Siddhartha Gadgil -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'logictypesandspaces';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://siddhartha-gadgil.github.io//github/blog/2015/02/02/logic-from-types/';
        var disqus_url = 'http://siddhartha-gadgil.github.io//github/blog/2015/02/02/logic-from-types/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
