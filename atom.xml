<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Logic, Types and Spaces]]></title>
  <link href="http://siddhartha-gadgil.github.io//github/atom.xml" rel="self"/>
  <link href="http://siddhartha-gadgil.github.io//github/"/>
  <updated>2015-02-03T09:21:03+05:30</updated>
  <id>http://siddhartha-gadgil.github.io//github/</id>
  <author>
    <name><![CDATA[Siddhartha Gadgil]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fin Type Family]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2015/01/30/fin-type-family/"/>
    <updated>2015-01-30T10:55:34+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2015/01/30/fin-type-family</id>
    <content type="html"><![CDATA[<p>We briefly saw the <strong>Fin</strong> type family when constructing trees. We clarify and elaborate on its construction.</p>

<p>The <strong>Fin</strong> type family is indexed by natural numbers $\mathbb{N}$. For $n : \mathbb{N}$, $Fin(n)$ is a finite type with $n$ elements, corresponding to the integers $k$ with $0 \leq k &lt; n$. We denote by $[k]_n$ the element corresponding to the natural number $k$ in $Fin(n)$. Note that $[1]_2$ and $[1]_3$ are <strong>not</strong> the same term even though they correspond to the same natural number.</p>

<p>We define $Fin$ as an inductive type family with two constructors. In Agda, this is as follows.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Fin</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">fzero</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line">  <span class="n">fsucc</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The constructors are similar to the $zero$ and $succ$ constructors for natural numbers. However, as remarked earlier,  $[0]_2$ and $[0]_3$ are <strong>not</strong> the same term, so the constructor $fzero$ takes an argument specifying the type of the term constructed. Since $Fin(0)$ does not have a term corresponding to $0$, but $Fin(k)$ does for $k \geq 1$, we set $fzero(n) = [0]_{n +1}$. Formally, as usual, we only specify the type of $fzero$ and declare it to be a constructor.</p>

<p>The second constructor $fsucc$ takes $[k]_n$ to $[ k + 1]_{n +1}$. On the associated natural numbers, this is just the successor function. However it maps the type $Fin(n)$ to the type $Fin(n+1)$ - as one should expect since, given $0 \leq k &lt; n$, we need not have $k + 1 &lt;n$, but always have $0 \leq k+1 \leq n +1$.</p>

<p>Note that if $0\leq k &lt;n$, then there is unique way to obtain $[k]_n$ using the given constructors, namely (using powers to denote iterated application) $[k]_n = fsucc^k (fzero (n -k -1))$.</p>

<p>By a recursive definition, we can define the function $[k]_n \mapsto k$.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_as</span><span class="err">ℕ</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="n">n</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">fzero</span> <span class="n">as</span><span class="err">ℕ</span> <span class="ow">=</span> <span class="mi">0</span>
</span><span class="line"><span class="p">(</span><span class="n">fsucc</span> <span class="n">k</span><span class="p">)</span> <span class="n">as</span><span class="err">ℕ</span> <span class="ow">=</span> <span class="n">succ</span> <span class="p">(</span><span class="n">k</span> <span class="n">as</span><span class="err">ℕ</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rooted Trees and General Induction]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2015/01/25/rooted-trees-and-general-induction/"/>
    <updated>2015-01-25T09:36:02+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2015/01/25/rooted-trees-and-general-induction</id>
    <content type="html"><![CDATA[<p>We now consider a more complex example, which illustrates the most general form of constructors for inductive types.</p>

<p>A rooted tree with leaf labels of type $A$ is a structure built recursively, being of one of the forms:</p>

<ul>
  <li>a single vertex, which is the root, with a label from $A$, or</li>
  <li>a vertex, the root, to which are attached finitely many rooted trees with leaf labels by an edge to their roots.</li>
</ul>

<p>To model this, specifically to model “finitely many rooted trees”, we introduce the inductive type family associating to a natural number $n: \mathbb{N}$ the set of natural numbers less than $n$.</p>

<h2 id="the-fin-type-family">The Fin type family.</h2>

<p>We construct an inductive type family $Fin: \mathbb{N} \to \mathcal{U}$, with $Fin(n)$ consisting of integers $k$ with $0 \leq k &lt; n$. For $n &gt;0$, this has an element $0$. Further, if $k$ gives an element of $Fin(n)$, then $k + 1$ is an element of $Fin(n +1)$. It is easy to see that these give the constructors of the type family. Thus,</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Fin</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">fzero</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line">  <span class="n">fsucc</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="inductive-family-for-rooted-trees">Inductive family for rooted trees.</h2>

<p>Observe that for $n : \mathbb{N}$, a collection of $n$ objects of type $X$ can be viewed as a function $Fin(n) \to X$. To consider all finite trees we consider terms of type $\Pi_{n : \mathbb{N}} Fin(n)\to X$. Using this, we can define the inductive type of rooted trees with leaf labels of type $A$.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">RootedTree</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">leaf</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">RootedTree</span> <span class="kt">A</span>
</span><span class="line">  <span class="n">node</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="kt">Fin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">RootedTree</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="kt">RootedTree</span> <span class="kt">A</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="constructors-recursion-and-induction-generalized">Constructors, Recursion and Induction generalized</h2>

<p>Note that the constructor for rooted trees is not of the earlier forms, but a more general form. For a type $W$, we can regard a term of $A \to W$ as giving a family of terms of $W$, indexed by $A$. More generally, we can construct families by regarding $W$ itself as the type of a family, and regarding functions, and dependent functions, to families of terms of $W$ as families of terms of $W$. Note that the domains cannot involve $W$.</p>

<p>We add another rule for types of constructors for $W$. This completes our list of constructors, so we now have the full definition of inductive types.</p>

<ul>
  <li>If $T$ is the type of a constructor of $W$, and $V = \dots \to W$ is the type of a family of terms of $W$, then $V \to W$ can be the type of a constructor.</li>
</ul>

<p>Consider recursive and inductive definitions on rooted trees, or more generally inductive types with constructors including the new type. The value of a function on a node can depend on values on each of the rooted trees that constitute it. To formalize this, observe that if $\alpha: A \to W$ is a family of terms of type $W$, and $f : W\to X$, then we obtain a function $f \circ \alpha: A \to X$ by composition. The value of $f$ on the image of the constructor can depend on $F \circ \varphi$.</p>

<p>We thus make the following rule for $R_{W, X}$, which is easy to generalize to arbitrary families and to induction functions.</p>

<ul>
  <li>If $T$ is the type of a constructor of of $W$, $A$ is a type and $\alpha : A \to W$ is a variable (or term), then for a constructor $\varphi : (A \to W) \to T$, we have $R_{W, X}(\varphi) = (A \to W) \to (A \to X) \to R_{W, X}(\varphi(\alpha))$.</li>
</ul>

<h2 id="exercise">Exercise:</h2>

<ul>
  <li>
    <p>Define a fold function, which, given $n : \mathbb{N}$ (which can be inferred), $f: Fin(n) \to A$ and $\_ *\_ : A \times B \to B$, for types $A$ and $B$, has result
$f(0) * (f(1) * (\dots * (f(n-1) * b)))$</p>
  </li>
  <li>
    <p>Define a function that, given a rooted tree with leaf labels in $A$ gives the list of labels.</p>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Constructing Dependent Functions]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2015/01/23/constructing-dependent-functions/"/>
    <updated>2015-01-23T10:21:48+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2015/01/23/constructing-dependent-functions</id>
    <content type="html"><![CDATA[<p>While we have introduced dependent functions, we do not formally have any way to construct them - those constructed so far used pattern matching. We shall generalize the two ways we have seen to construct functions, <em>lambdas</em> and using <em>recursion functions</em> to constructions of dependent functions. In doing so we also review and clarify the case of ordinary functions.</p>

<h2 id="lambdas">Lambdas</h2>

<p>We can construct a function of type $A \to B$ as a lambda, i.e., we consider an $\lambda$-expression $\lambda a \to b$, which is usually denoted $a \mapsto b$ in mathematics. More precisely,</p>

<ul>
  <li>$a$ is a variable of type $A$. This is just a term with a name, which we temporarily introduce. Note that the type $A$ may not have any terms at all.</li>
  <li>$b$ is an expression (judgmentally) of type $B$ which can involve $a$. This means that $b$ is a term formed by the usual rules for forming terms - applying a function to an argument, constructing function types, lambdas etc., except that we can use the term $a : A$ along with other terms previously introduced to the context.</li>
  <li>When we apply $\lambda a \to b$ to $a’ : A$, we obtain the result of <em>substituting</em> $a’$ for $a$ in $b$. For this to be meaningful, it is to be understood that our rules for forming terms include rules for <em>substitution</em>.</li>
</ul>

<p>It is clear how to generalize this to obtain dependent functions, with type say $\Pi_{a : A} B(a)$. Namely, we consider terms $\lambda a \to b$ so that the expression $b$ has type $B(a)$.</p>

<h2 id="recursion-functions-revisited">Recursion functions revisited.</h2>

<p>Functions on inductive types can be constructed using associated recursion functions. We clarify this in the case of the simple inductive types we have considered so far, and extend this to some more general inductive types.</p>

<h4 id="constructors-for-w">Constructors for $W$</h4>

<p>For a type $W$, previously, we considered constructors as terms with type that can be obtained in the following ways.</p>

<ul>
  <li>$W$ itself can be the type of a constructor.</li>
  <li>If $T$ is the type of a constructor, then $W \to T$ can also be a type of a constructor for $W$.</li>
  <li>If $T$ is the type of a constructor and $A$ is a type not involving $W$, then $A \to T$ can also be a type of a constructor for $W$.</li>
</ul>

<p>It may seem that any type $X$ should fall into one of the latter two cases, but this is not so. For example $W \to W$ is not in either case, and indeed $(W \to W) \to W$ is not a valid type for a constructor.</p>

<p>Observe that for a constructor $g$ of the type $W \to T$, if $b : B$ then $g(b)$ is also a constructor, and we have a similar statement for the type being $A \to W$.</p>

<p>We now look at two more ways of obtaining constructors, with functions in the second and third rule above generalized to dependent functions.</p>

<ul>
  <li>If we have a function associating to $w : W$ the type $T(w)$ of a constructor for $W$, then $\Pi_{w : W} T(w)$ can also be the type of a constructor.</li>
  <li>If $A$ is a type not involving $W$ and we have a function associating to $a : A$ the type $T(a)$ of a constructor for $W$, then $\Pi_{a : A} T(a)$ can also be the type of a constructor.</li>
</ul>

<h4 id="domains-of-recursion">Domains of Recursion</h4>

<p>Given a constructor $\varphi$ for $W$ and a type $X$, we obtain a type which we call the <em>domain of recursion</em> of $\varphi$ and denote $R_{W, X}(\varphi)$. For constructors obtained using the above rules, we define this as follows. Note that we could have defined this purely in terms of the type of $\varphi$, but we chose the definition to be parallel to the case for dependent functions.</p>

<ul>
  <li>If $\varphi : W$, then $R_{W, X}(\varphi) = W$.</li>
  <li>If $\varphi : W \to T$ and $w : W$ is a variable (or term), then $R_{W, X}(\varphi) = W \to X \to R_{W, X}(\varphi(w))$. Note that this does not depend on the choice of $w : W$. Indeed it is determined by the type $T$ of $\varphi(w)$.</li>
  <li>If $\varphi : A \to T$ and $a : W$ is a variable (or term), then $R_{W, X}(\varphi) = A \to R_{W, X}(\varphi(w))$. Note that this does not depend on the choice of $a : A$. Indeed it is determined by the type $T$ of $\varphi(a)$.</li>
  <li>If $\varphi : \Pi_{w: W} T(w)$, then $R_{W, X}(\varphi) = \Pi_{w: W} (W \to X \to R_{W, X}(\varphi(w))).$</li>
  <li>If $\varphi : \Pi_{a: A} T(a)$ with the type $A$ not involving $W$, then $R_{W, X}(\varphi) = \Pi_{a: A} (A \to R_{W, X}(\varphi(w))).$</li>
</ul>

<p>If we have a type such as $W \to W$ that involves $W$ but is not equal to $W$, it is not clear whether the second or third ruls applies. We shall eventually allow some such types, but not others. For these we will extend the rules for $W$.</p>

<h4 id="the-recursion-function">The recursion function</h4>

<p>Suppose now that $W$ is given by constructors $\varphi_1$, $\dots$, $\varphi_k$. Then when defining $W$, we introduce for each type $X$ a term $rec_{W, X}$ with type</p>

<script type="math/tex; mode=display">rec_{W, X} : R_{W, X}(\varphi_1) \to \dots \to R_{W, X}(\varphi_k) \to (W \to X)</script>

<p>We make certain judgments, giving definitional equalities involving the recursion function.</p>

<h2 id="induction-functions">Induction functions</h2>

<p>It is straightforward to modify the above for definitions of dependent functions. The analogues of recursive definitions for dependent functions are called <em>inductive definitions</em>, and these are interpreted in terms of <em>induction functions</em>.</p>

<h4 id="for-natural-numbers">For natural numbers</h4>

<p>First we briefly consider an example, namely dependent functions on $\mathbb{N}$. Suppose $X : \mathbb{N} \to \mathcal{U}$ is a type family. To define inductively a dependent function $f : \Pi_{n : \mathbb{N}} X(n)$, we must specify</p>

<ul>
  <li>$f(0)$, of type $X(0)$.</li>
  <li>For all $n$, $f(n + 1) : X(n+1)$ in terms of $n : \mathbb{N}$ and $f(n) : X(n)$.</li>
</ul>

<p>Thus we require a term of type $X(0)$, and for each $n$, a term of type $X(n+1)$ as a function of a term of type $\mathbb{N}$ and a term of type $X(n)$. The latter data can be viewed as a single term of type $\Pi_{n : \mathbb{N}} (X(n) \to X(n+1))$. Thus, the induction function for natural numbers has the type</p>

<script type="math/tex; mode=display">ind_{W, X} :  X(0) \to \Pi_{n : \mathbb{N}} (X(n) \to X(n+1)) \to \Pi_{n : \mathbb{N}} X(n).</script>

<p>Notice that this type involves the expression $n+1 = succ(n)$, so the type depends on the constructor $\varphi$, not just its type.</p>

<h4 id="domains-of-induction">Domains of induction</h4>

<p>Given now a type family $X$, we define for constructors $\varphi$ constructed as above a type $I_{W, X}(\varphi)$ as follows.</p>

<ul>
  <li>If $\varphi : W$, then $I_{W, X}(\varphi) = W$.</li>
  <li>If $\varphi: W \to T$, then $I_{W, X}(\varphi) = \Pi_{w: W} (X(w) \to I_{W, X}(\varphi(w)))$.</li>
  <li>If $\varphi: A \to T$, then $I_{W, X}(\varphi) = \Pi_{a: A} I_{W, X}(\varphi(a))$.</li>
  <li>If $\varphi: \Pi_{w: W} T(w)$, then $I_{W, X}(\varphi) = \Pi_{w: W} (X(w) \to I_{W, X}(\varphi(w)))$.</li>
  <li>If $\varphi: \Pi_{a : A} T(a)$, then $I_{W, X}(\varphi) = \Pi_{a: A} I_{W, X}(\varphi(a))$.</li>
</ul>

<p>Observe that the constructors involving dependent functions are essentially the same as those involving ordinary functions.</p>

<h4 id="the-induction-function">The induction function</h4>

<p>This can now be introduced in a manner similar to the recursion function. Suppose now that $W$ is given by constructors $\varphi_1$, $\dots$, $\varphi_k$. Then when defining $W$, we introduce for each type family $X$ a term $ind_{W, X}$ with type</p>

<script type="math/tex; mode=display">rec_{W, X} : I_{W, X}(\varphi_1) \to \dots \to I_{W, X}(\varphi_k) \to (\Pi_{w: W} X(w)).</script>

<p>We make certain judgments, giving definitional equalities involving the induction function.</p>

<h2 id="inductive-type-families">Inductive type families</h2>

<p>We now sketch the generalization to <em>inductive type families</em>.</p>

<h4 id="type-families">Type families</h4>

<p>A type family is one of:
* A type $W : \mathcal{U}$.
* A function from a type $A$ to type families.</p>

<p>Thus, a typical type family is $A \to B \to \mathcal{U}$ or $\Pi_{a : A} (B(a)\to mathcal{U})$.</p>

<h4 id="inductive-type-families-1">Inductive type families</h4>

<p>An inductive type family, say $W : A \to \mathcal{U}$, is a type family which is determined by constructors and for which there are recursion and induction functions. The most important point to note about such a family is that even though, for $a: A$, $W(a)$ is a type, it is <strong>not</strong> an inductive type. For instance, for a type $X$ we do not have a recursion function $rec_{W(a), X}$. Instead we can recursively (and inductively) define (dependent) functions for all values of the index, i.e., we have a recursion function with type of the form</p>

<script type="math/tex; mode=display">rec_{W, X} : \dots \to \Pi_{a : A}(W(a) \to X)</script>

<p>and similarly for inductive functions.</p>

<h4 id="constructors-for-families">Constructors for families.</h4>

<p>Consider an inductive type family $W : A \to \mathcal{U}$. It is meaningless to talk of a constructor of type $W$, as $W$ is not a type. Instead basic constructors for such families are of the form $W(a)$ for $a : A$. Similarly, we can extend a constructor $T$ to $W(a’) \to T$.</p>

<p>Definitions of recursion and induction functions for type families from constructors are easy generalizations of the definitions for inductive types.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dependent Function Types: Sections of a Bundle]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2015/01/22/dependent-function-types/"/>
    <updated>2015-01-22T17:56:43+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2015/01/22/dependent-function-types</id>
    <content type="html"><![CDATA[<h2 id="dependent-functions">Dependent functions</h2>

<p>A function $f$ on a domain $A$ when applied to an elements $a$ of type $A$ gives a value $f(a)$. Further, a function is determined by the values it gives, in the sense that if $f$, $g$ are functions with domain $A$ so that</p>

<script type="math/tex; mode=display">\forall x\in A, f(x) = g(x)</script>

<p>then
<script type="math/tex">f=g.</script></p>

<p>Dependent functions generalize functions, with the above properties continuing to hold. What we no longer require is that $f(a)$ has a fixed type independent of $a$, namely the codomain B. Instead we have a family of codomains $B(a)$, so that $f(a)$ has type $B(a)$.</p>

<p>Such objects are common in mathematics (and physics). For example, the velocity of water flowing on a sphere  gives a vector field on a sphere. At a point $x$ on the sphere, the value of the vetor field $V$ lies in the tangent space at the point, i.e.,</p>

<script type="math/tex; mode=display">V(x) \in T_x S^2.</script>

<p>Hence it is best to view vector fields as dependent functions. In mathematics, the codomains are generally called fibers, which together form a fiber bundle, and dependent functions are called sections of this bundle.</p>

<p>We can (and often do) regard a dependent function as an ordinary function with codomain the union of the various codomains. But, besides losing information, the function we get is not natural, in the sense that it does not respect the underlying symmetries.</p>

<h2 id="products-and-pi-types">Products and $\Pi$-types</h2>

<p>Another situation which is best viewed in terms of dependent functions is a product. Consider a product $A_1 \times A_2 \times \dots \times A_n$. An element of such a product is a tuple $(a_a, a_2, dots, a_n)$. We would like to view such tuples as functions $a$ on the index set $\{1, 2, \dots, n\}$, but to do so we would have to require $a(i) : A_i$, i.e., a separate codomain for each index. Thus tuples are dependent functions.</p>

<p>More generally, if we have a family of types $B(a)$ indexed by a set $A$, then elements of the product</p>

<script type="math/tex; mode=display">\Pi_{a : A} B(a)</script>

<p>are exactly dependent functions $f$ on $A$ so that $f(a)$ has type $B(a)$ for $a : A$. Thus a type of dependent functions is denoted as in $\Pi_{a : A} B(a)$ and is often called a $\Pi$-type.</p>

<h2 id="examples-and-code">Examples and code</h2>

<p>We now turn to some simple examples and code. First we consider type families, which give the collection of codomains for dependent functions. The typical example is vectors of length $n$ of elements of a type $A$. Formally, a type family is just a function with codomain a universe, so the values the function takes are types.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>The Type family of vectors of length n</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Vec</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">)</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="kt">[]</span>   <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">zero</span>
</span><span class="line">  <span class="kr">_</span><span class="ow">::</span><span class="kr">_</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This gives a family of types <em>parametrized</em> by A and <em>indexed</em> by natural numbers. The difference between parameters and indices is a bit subtle but crucial. Observe that the Agda syntax treats them quite differently.</p>

<h3 id="inductive-types-and-inductive-type-families">Inductive types and inductive type families</h3>

<p>We defined Booleans and natural numbers using the data statement, and defined functions on them by pattern matching. More conceptually, these are inductive types, and functions defined on them are defined by applying the recursion function. For instance, in the case of Booleans, the recursion function takes as input a type $A$ and two objects with that type (the values of $true$ and $false$) and gives a function from Booleans to $A$.</p>

<p>In the case of lists, for each type $A$, we obtain a corresponding inductive type. Thus we have a family of inductive types, parametrized by the type $A$.</p>

<p>In the case of vectors too, the type $A$ acts as a parameter.  Assume that the type $A$ is fixed, so vectors are now a family of types indexed by natural numbers.</p>

<p>However, the vectors of a fixed size (say $7$) do not form an inductive type - we cannot define a function recursively on vectors of length $7$ alone.  In this case, this is evident from the definition, as the constructor giving vectors of size $7$ uses vectors of size $6$. So a recursive definition must also involve vectors of size $6$, hence of $5$ etc.</p>

<p>We can, however, recursively define functions on vectors of all sizes, i.e., of all values of the index. For examples, here is the function that appends (adds to the end) an element to a vector.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Appending to a vector</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">_</span><span class="kt">:+</span><span class="kr">_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line"><span class="nf">a</span> <span class="kt">:+</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">a</span> <span class="ow">::</span> <span class="kt">[]</span>
</span><span class="line"><span class="nf">a</span> <span class="kt">:+</span> <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:+</span> <span class="n">xs</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Thus, vectors form an inductive type family indexed by natural numbers (and parametrized by A). As we remarked, the type for a given index is not an inductive type. Note that even in cases where we can meaningfully write down a recursion rule for the type at a fixed index, such a recursion rule does not hold, i.e., there is no recursion function using which we can translate pattern matching into function applicatio.</p>

<p><strong>Remark:</strong> From the point of view of programming languages, there is another sense in which indexing by natural numbers is different from parametrizing by types - the types we construct depend on <em>objects</em>, not just other types. Modern languages usually allow types to depend on other types (sometimes called generics), but most do not allow dependence on objects.</p>

<h3 id="a-dependent-function">A dependent function</h3>

<p>We shall now construct a dependent function <em>countdown</em> that maps a natural number $n$ to the list consisting of natural numbers from $n$ down to $0$. Thus the type of $countdown(n)$ is vectors of natural numbers of length $n+1$.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>countdown : a dependent function</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">countdown</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="err">ℕ</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line"><span class="nf">countdown</span> <span class="n">zero</span> <span class="ow">=</span> <span class="n">zero</span> <span class="ow">::</span> <span class="kt">[]</span>
</span><span class="line"><span class="nf">countdown</span> <span class="p">(</span><span class="n">succ</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">succ</span> <span class="n">m</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">countdown</span> <span class="n">m</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The definition in terms of pattern matching is similar to recursive definitions of functions. In terms of homotopy type theory, dependent functions on inductive types are constructed by applying a dependent function called the <em>induction function</em> to the data.</p>

<p>As mentioned earlier, the type of a dependent function is called the <em>product type</em> corresponding to the family of types with base the domain. For instance, the type of countdown is</p>

<script type="math/tex; mode=display">\prod\limits_{n : \Bbb{N}} Vec (\Bbb{N}) (n+1).</script>

<p>Except for universes (which we will keep in the background as far as possible), we have now seen all the type constructions - inductive types, functions and dependent functions.</p>

<h2 id="dependent-pairs">Dependent pairs</h2>

<p>Besides dependent products, the other fundamental dependent type associated to a type $A$ and a family of types $B: A \to \mathcal{U}$ is the <em>dependent sum type</em>, denoted $\Sigma_{a : A} B(a)$, whose elements are pairs $(a, b)$ with $a : A$ and $b : B(a)$. Like the pair type $A \times B$, this can be defined as an inductive type.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="err">Σ</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Type</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="p">[</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">]</span> <span class="kt">:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="kt">B</span> <span class="n">a</span><span class="p">)</span> <span class="err">→</span> <span class="err">Σ</span> <span class="kt">A</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="type-checking-with-dependent-types">Type checking with dependent types</h3>

<p>A principal use of types in programming is to avoid writing meaningless expressions, by ensuring that such expressions violate the rules for constructing objects and types. Dependent types are even better than this. For instance, consider the <em>zip</em> operation on vectors which associates to a vector of type $A$ with entries $a_i$ and a vector of type $B$ with entries $b_j$ a vector of type $A\times B$ with entries pairs $(a_i, b_i)$. This makes sense only when both vectors have the same length. Using dependent functions and types, we can define the function in such a way that it is defined only on pairs of vectors with the same length.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Componentwise operation on vectors</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">zip</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="p">(</span><span class="kt">A</span> <span class="err">×</span> <span class="kt">A</span><span class="p">)</span> <span class="n">n</span>
</span><span class="line"><span class="nf">zip</span> <span class="kt">[]</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class="line"><span class="nf">zip</span> <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span> <span class="ow">::</span> <span class="n">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="p">[</span> <span class="n">x</span> <span class="p">,</span> <span class="n">y</span> <span class="p">]</span> <span class="ow">::</span> <span class="p">(</span><span class="n">zip</span> <span class="n">xs</span> <span class="n">ys</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Note that we could have used lists in place of vectors, but we would then have to give a definition that can lead to errors at runtime, or truncates perhaps giving unexpected values.</p>

<h2 id="exercise">Exercise:</h2>

<ul>
  <li>Define a function $vmap$ on vectors analogous to $map$ on lists.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Recursion Functions and Inductive Types]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2015/01/21/recursion-functions-and-inductive-types/"/>
    <updated>2015-01-21T08:36:41+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2015/01/21/recursion-functions-and-inductive-types</id>
    <content type="html"><![CDATA[<p>We have constructed various inductive types, and constructed functions on these types recursively. We have however not addressed the issue of what are valid definitions for inductive types and recursive functions. We now turn to these questions. The definition of inductive types we now consider is not the most general, but it includes all the examples so far.</p>

<h3 id="examples-recalled">Examples recalled</h3>

<p>Suppose now that we wish to define an inductive type $W$. We recall two previous types we have defined. For $W = \mathbb{N}$, we used the following  definition.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="err">ℕ</span> <span class="kt">:</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">zero</span> <span class="kt">:</span> <span class="err">ℕ</span>
</span><span class="line">  <span class="n">succ</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Lists are a parametrized inductive type, which means that for each type $A$ we get a list of type $A$. We focus on the case where $A =\mathbb{N}$, so the inductive definition of $List\mathbb{N}=List\  \mathbb{N}$ becomes the following.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">List</span><span class="err">ℕ</span> <span class="kt">:</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="kt">[]</span> <span class="kt">:</span> <span class="kt">List</span><span class="err">ℕ</span>
</span><span class="line">  <span class="kr">_</span><span class="ow">::</span><span class="kr">_</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">List</span><span class="err">ℕ</span> <span class="err">→</span> <span class="kt">List</span><span class="err">ℕ</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="constructors">Constructors.</h2>

<p>The inductive type $W$ is defined by constructors, which are curried functions that give an element in $W$, with the arguments possibly in $W$. In the above examples, the constructors have types:</p>

<ul>
  <li>For $W = \mathbb{N}$, $zero$ has type $W$ and $succ$ has type $W \to W$.</li>
  <li>For $W = List\mathbb{N}$, $[]$ has  type $W$ and $\_::\_$ has  type $\mathbb{N}\to W \to W$.</li>
</ul>

<p>It is clear how to generalize these. A constructor for a type $W$ can be:</p>

<ul>
  <li>$W$ itself (which we can think of as a function of no arguments giving $W$, i.e. $W = \to W$).</li>
  <li>obtained from a constructor type  $T =\dots \to W$ by mapping $W$ to this constructor type to get $W \to T = W \to \dots \to W$.</li>
  <li>obtained from a constructor type $T = \dots \to W$ by mapping a type $A$ not involving $W$ to this constructor type to get $A \to T = A \to \dots \to W$.</li>
</ul>

<p>We shall later see some other ways of building constructors. For the present, observe that all our examples so far, $\mathbb{N}$, $List A$, $Bool$, $A \times B$ and $A \oplus B$  are  all of this form. We shall next see what we mean by recursive definitions on such inductive types.</p>

<h2 id="recursive-definitions">Recursive definitions.</h2>

<p>We shall associate with an inductively defined type $W$ and another type $X$ a function $rec_{W, X}$ which has arguments the ingredients of a recursive definition and gives a function from $W$ to $X$. So the type of $rec_{W, X}$ is  of the form $\dots \to (W \to X)$.</p>

<p>First, consider the case when $W = \mathbb{N}$. A recursive function $f: W \to X$ is defined by specifying its value on $zero$ and on $succ(n)$ for $n \in \mathbb{N}$. These values in turn are determined by terms, whose types we call $D_{zero}$ and $D_{succ}$. In terms of these, the type of $rec_{\mathbb{N}, X}$ is thus $D_{zero} \to D_{succ} \to \mathbb{N}$.</p>

<p>The function $f$ is determined on $zero$ by simply specifying its image $f(zero) : X$, so $D_{zero}$ is just $X$. On the other hand, for $n : \mathbb{N}$, $f(succ(n))$ is a function of $n$ and $f(n)$. So specifying the image of $f$ on all numbers of the form $f(succ(n))$ amounts to giving a function $\mathbb{N} \to X \to X$, with the first argument to be applied to $n$ and the second to $f(n)$.</p>

<p>Thus, the recursion function of $\mathbb{N}$ has the type</p>

<script type="math/tex; mode=display">rec_{\mathbb{N}, X} : X \to (\mathbb{N} \to X \to X) \to (\mathbb{N} \to X)</script>

<p>Next, consider the case of lists of natural numbers. Again, we define a function $f$ recursively to a type $X$ in terms of the value on the result of each constructor. For the empty list, the value of $f$ is simply given by $f([]) : X$. On the other hand, for a list of the form $head :: tail$, the value of $f$ can be a function of $head$, $tail$ and $f(tail)$. Thus, we have a recursion function with the type</p>

<script type="math/tex; mode=display">rec_{List \mathbb{N}, X} : X \to (\mathbb{N} \to List \mathbb{N} \to X \to X) \to (List \mathbb{N} \to X)</script>

<p>It is easy to generalize these examples to an inductive type $W$ of the form we are considering. Namely, we associate to a constructor type $T$ a recursion data type $R_X(T)$ as follows:</p>

<ul>
  <li>if $T = W$, $R_X(T) = X$</li>
  <li>if $T = W \to T’$, $R_X(T) = W \to X \to R_X(T’)$</li>
  <li>if $T = A \to T’$ with $A$ independent of $W$, then $R_X(T) = A \to R_X(T’)$</li>
</ul>

<p>These rules tell us the type of the recursion functions. The recursion function satisfies certain <em>definitional equalities</em>, saying that it acts on the image of constructors as specified. For example, in the case of natural numbers, we get the identities:</p>

<ul>
  <li>$rec_{\mathbb{N}, X} (z) (f) (0) \equiv z$,</li>
  <li>$rec_{\mathbb{N}, X} (z) (f) (succ(n)) \equiv f (n) (rec_{\mathbb{N}, X} (z) (f) (n))$.</li>
</ul>

<p>In homotopy type theory, we view an inductive definition as introducing a type, constructor functions, a recursion function and certain definitional equalities. We shall see later the final ingredients of an inductive type definition, namely a so called <em>induction function</em> and corresponding definitional equalities.</p>

<p>In terms of Agda code, we can simply define the recursion functions. For instance, for natural numbers, we have:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">rec</span><span class="err">ℕ</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">X</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="kt">X</span> <span class="err">→</span> <span class="p">(</span><span class="err">ℕ</span> <span class="err">→</span> <span class="kt">X</span> <span class="err">→</span> <span class="kt">X</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="err">ℕ</span> <span class="err">→</span> <span class="kt">X</span><span class="p">)</span>
</span><span class="line"><span class="nf">rec</span><span class="err">ℕ</span> <span class="n">z</span> <span class="n">f</span> <span class="n">zero</span> <span class="ow">=</span> <span class="n">z</span>
</span><span class="line"><span class="nf">rec</span><span class="err">ℕ</span> <span class="n">z</span> <span class="n">f</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">n</span> <span class="p">(</span><span class="n">rec</span><span class="err">ℕ</span> <span class="n">z</span> <span class="n">f</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We shall construct the recursion functions in the other cases later. First, we shall see that we can make recursive definitions using the recursion function, without any pattern matching. In terms of Agda code, this means we need to use pattern matching only once - to construct the recursion function. In terms of homotopy type theory, all we use is that we have a recursion function of the appropriate type and that the corresponding definitional equalities hold.</p>

<h2 id="definitions-using-the-recursion-function">Definitions using the recursion function.</h2>

<p>We turn to examples of definitions using recursion functions. First we define the factorial. Note that in this definition $n!$ is just a variable name.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">_</span><span class="o">!</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="kr">_</span><span class="o">!</span> <span class="ow">=</span> <span class="n">rec</span><span class="err">ℕ</span> <span class="mi">1</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">n</span><span class="o">!</span> <span class="err">→</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="o">!</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Next, we define addition using the recursion function. This is a curried function $\_plus\_ : \mathbb{N} \to \mathbb{N} \to \mathbb{N}$, so $\_plus\_ (0) = 0\ plus\ \_$ is a function, namely the identity. Similarly $\_plus\_ (succ(n)) = (succ (n))\ plus\ \_$ is a function defined in terms of $n$ and $n\ plus\ \_$, where $n\ plus\ \_$ is the function <em>addition by $n$</em> (we use the variable name $nplus = \_ plus\_ (n)$). Clearly the following is a definition of addition (we have written this using nested lambdas for clarity).</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_plus_</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">_plus_</span> <span class="ow">=</span> <span class="n">rec</span><span class="err">ℕ</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="err">→</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">nplus</span> <span class="err">→</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="err">→</span> <span class="n">succ</span> <span class="p">(</span><span class="n">nplus</span> <span class="n">m</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Multiplication can be  defined similarly</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_times_</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">_times_</span> <span class="ow">=</span> <span class="n">rec</span><span class="err">ℕ</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="err">→</span> <span class="mi">0</span><span class="p">)(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">ntimes</span> <span class="err">→</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="err">→</span> <span class="p">(</span><span class="n">ntimes</span> <span class="n">m</span><span class="p">)</span> <span class="n">plus</span> <span class="n">m</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="foundations-so-far">Foundations so far.</h2>

<p>As you can observe, we have now defined functions purely in terms of lambdas and recursion function. Thus, we now have clear foundation rules. Namely,</p>

<ul>
  <li>We have (so far) two ways of constructing types - inductive types and function types.</li>
  <li>Terms can be constructed by applying a function $f: A \to B$ to a term $a : A$. We make the judgment $f(a) : B$.  </li>
  <li>Terms of function types are constructed using lambdas. A $\lambda$-term $A \to B$ is of the form $\lambda a \mapsto b$ where $b$ is an expression of type $b$, which can involve the variable (term)
$a : A$ and is otherwise built using the usual rules for forming terms.</li>
  <li>An inductive type $W$ is specified by specifying the types of constructors. The type of a constructor is built from $W$ in certain specified ways.</li>
  <li>When defining an inductive type, we define constructors as terms of the specified type.</li>
  <li>For an inductive type $W$ and a type $X$, we obtain a recursion function $rec_{W, X}$, whose type is determined in terms of the constructors of $W$. We have certain <em>computation</em> rules giving definitional equalities for the action of a recursively defined function on the image of a constructor.</li>
</ul>

<p>We need a few more rules of a similar nature, mainly concerned with extending rules involving functions to so called <em>dependent functions</em>. Our next goal is to introduce dependent functions.</p>

<h2 id="exercise">Exercise</h2>

<ul>
  <li>Define the recursion functions $recBool$ on Booleans.</li>
  <li>Define the recursion function $recList(A)$ as a function of $A : Type$.</li>
  <li>Define $not$, $\_ \&amp; \_$  and $\_contains&#92;_$ in terms of the above recursion functions without using any pattern matching.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Program : Lattice Points in a Circle]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2015/01/20/a-program/"/>
    <updated>2015-01-20T15:11:46+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2015/01/20/a-program</id>
    <content type="html"><![CDATA[<p>We now give a program (i.e., a function) that, given a natural number $n$, lists all points in the plane with co-ordinates natural numbers, which are contained in the circle of radius $n$. This illustrates how we can implement a combination of nested loops and conditions using <em>map</em>, <em>flatMap</em> and <em>filter</em>.</p>

<p>We first define a function $leq$, denoting less than or equal to, for natural number. We have reserved $\leq$ for something nicer. This is a recursive definition.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_leq_</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Bool</span>
</span><span class="line"><span class="nf">zero</span> <span class="n">leq</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">true</span>
</span><span class="line"><span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="n">leq</span> <span class="n">zero</span> <span class="ow">=</span> <span class="n">false</span>
</span><span class="line"><span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="n">leq</span> <span class="p">(</span><span class="n">succ</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="n">n</span> <span class="n">leq</span> <span class="n">m</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can now construct the function we promised. For each $a \in \mathbb{N}$, we can define a function associating to it a list by filtering $b\in \mathbb{N}$ by requiring the pair $(a , b)$ to lie in the circle, and then map to the pair $(a, b)$. We flatMap using this list-valued function.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">points</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">List</span> <span class="p">(</span><span class="err">ℕ</span> <span class="err">×</span> <span class="err">ℕ</span><span class="p">)</span>
</span><span class="line"><span class="nf">points</span> <span class="n">n</span> <span class="ow">=</span> <span class="p">(</span><span class="n">upto</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">))</span> <span class="n">flatMap</span> <span class="p">(</span><span class="err">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="p">((</span><span class="n">upto</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">))</span> <span class="n">filter</span> <span class="p">(</span><span class="err">λ</span> <span class="n">b</span> <span class="err">→</span> <span class="p">((</span><span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">))</span> <span class="n">leq</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span><span class="n">points</span> <span class="p">))</span> <span class="n">map</span> <span class="p">(</span><span class="err">λ</span> <span class="n">b</span> <span class="err">→</span> <span class="p">[</span> <span class="n">a</span> <span class="p">,</span> <span class="n">b</span> <span class="p">]))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We have used <em>map</em>, <em>flatMap</em> and <em>filter</em> to replace nested loops and control statements (<em>if</em> in this case) in older programming languages. In imperative code we would have started with an empty list, used a loop for $a$, an inner one for $b$ and added to the list pairs that satisfy the condition of lying in the circle.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Products and Sums]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2015/01/16/products-and-sums/"/>
    <updated>2015-01-16T16:22:28+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2015/01/16/products-and-sums</id>
    <content type="html"><![CDATA[<p>Given types $A$ and $B$, we can combine them to get the product types $A\times B$ and the sum type $A \oplus B$. These are both inductive types parametrized by $A$ and $B$.</p>

<h2 id="the-product">The Product</h2>

<p>A term in the product $A \times B$ corresponds to an element of $A$ and an element of $B$. Hence we can define the product using a single constructor. We use square brackets for pairs as parenthesis have other meanings in Agda.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kr">_</span><span class="err">×</span><span class="kr">_</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="p">[</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">]</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">×</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="the-direct-sum">The (direct) Sum</h2>

<p>The direct sum $A \oplus B$ of types $A$ and $B$ can be thought of as the type whose elements are the elements of $A$ and the elements of $B$. Formally we have inclusion maps $\iota_j$ from the given types. Hence we get a description with two constructors.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kr">_</span><span class="err">⊕</span><span class="kr">_</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="err">ι₁</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">⊕</span> <span class="kt">B</span>
</span><span class="line">  <span class="err">ι₂</span> <span class="kt">:</span> <span class="kt">B</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">⊕</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fun With Lists]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2015/01/13/fun-with-lists/"/>
    <updated>2015-01-13T07:39:57+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2015/01/13/fun-with-lists</id>
    <content type="html"><![CDATA[<p>We continue working with lists. We have already mapped and flatmapped lists. We shall see how to filter, fold and find, letting us do some actual programming, i.e., with answers that are numbers. We shall also see if-expressions and option types.</p>

<h3 id="filtering--and-if-then-else">Filtering  and if-then-else</h3>

<p>Let us start with a function checking if a list contains an element with a certain property.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>checking if a list contains an element with a given property</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_contains_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span> <span class="err">→</span> <span class="p">(</span><span class="kt">A</span> <span class="err">→</span> <span class="kt">Bool</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Bool</span>
</span><span class="line"><span class="kt">[]</span> <span class="n">contains</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">false</span>
</span><span class="line"><span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="n">xs</span><span class="p">)</span> <span class="n">contains</span> <span class="n">p</span> <span class="ow">=</span> <span class="p">(</span><span class="n">p</span> <span class="n">x</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">xs</span> <span class="n">contains</span> <span class="n">p</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Before turning to filtering, we define an <em>if expression</em>, which gives one of two values depending on whether a Boolean term is $true$ or $false$. Note that this is not an if statement, doing something according to a condition, but a function that returns a value depending on the condition.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>if expression</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">if_then_else</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Bool</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">A</span>  <span class="err">→</span> <span class="kt">A</span>
</span><span class="line"><span class="kr">if</span> <span class="n">true</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">x</span>
</span><span class="line"><span class="kr">if</span> <span class="n">false</span> <span class="kr">then</span> <span class="kr">_</span> <span class="kr">else</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">y</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>With this in hand, we define a function filtering elements of a list by a given property. This is defined inductively, using the if expression to decide whether to prepend the first element.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>filtering a list</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_filter_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span> <span class="err">→</span> <span class="p">(</span><span class="kt">A</span> <span class="err">→</span> <span class="kt">Bool</span><span class="p">)</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span>
</span><span class="line"><span class="kt">[]</span> <span class="n">filter</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class="line"><span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="n">xs</span><span class="p">)</span> <span class="n">filter</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">if</span> <span class="p">(</span><span class="n">p</span> <span class="n">x</span><span class="p">)</span> <span class="kr">then</span> <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="p">(</span><span class="n">xs</span> <span class="n">filter</span> <span class="n">p</span><span class="p">))</span> <span class="kr">else</span> <span class="p">(</span><span class="n">xs</span> <span class="n">filter</span> <span class="n">p</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="folding">Folding</h3>

<p>So far we have defined many objects and types, but not actually computed anything concrete. To do this, we shall use a very useful function on lists, folding. This is a function that takes as input:</p>

<ul>
  <li>A list of type $A$, say $[ a_ 0, a_ 1 \dots, a_ n ]$.</li>
  <li>An element of type $B$, say $b : B$.</li>
  <li>A binary operation that lets us multiply (or add) an element of $A$ to (the left of) an element of $B$, $op : A \to B \to B$.</li>
</ul>

<p>The fold is obtained by starting with the given element in B, and successively multiplying on the left by elements of the list, starting with the rightmost. This stops when the list is empty, giving an element in B. Thus, if we omit parenthesis (assuming associativity of the operation), and if * denotes the operation, then folding is the function</p>

<script type="math/tex; mode=display">fold([a_0, a_1, \dots, a_n], b) = a_0*a_1 * \dots * a_n *b</script>

<p>As usual, we define the fold function recursively.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Folding a list</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">fold_by_from_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span> <span class="err">→</span> <span class="p">(</span><span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span> <span class="err">→</span> <span class="kt">B</span><span class="p">)</span> <span class="err">→</span> <span class="kt">B</span> <span class="err">→</span> <span class="kt">B</span>
</span><span class="line"><span class="nf">fold</span> <span class="kt">[]</span> <span class="n">by</span> <span class="kr">_</span> <span class="n">from</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">b</span>
</span><span class="line"><span class="nf">fold</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">as</span><span class="p">)</span> <span class="n">by</span> <span class="n">op</span> <span class="n">from</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">op</span> <span class="n">a</span> <span class="p">(</span><span class="n">fold</span> <span class="n">as</span> <span class="n">by</span> <span class="n">op</span> <span class="n">from</span> <span class="n">b</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="a-program">A program</h3>

<p>Equipped with our list operations, we now give a function computing the sums of squares of numbers from 1 to n. After importing natural numbers, we define (recursively) a function that gives the list of numbers from 1 to n. We then map this to get a list of squares. Finally, we fold this by the addition function to get the sum of squares.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Sum of squares</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">open</span> <span class="kr">import</span> <span class="nn">Nat</span>
</span><span class="line">
</span><span class="line"><span class="nf">upto</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">List</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">upto</span> <span class="n">zero</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class="line"><span class="nf">upto</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">upto</span> <span class="n">n</span><span class="p">)</span> <span class="o">++</span> <span class="p">((</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">[]</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">listsqs</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">List</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">listsqs</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">upto</span> <span class="n">n</span> <span class="n">map</span> <span class="p">(</span><span class="err">λ</span> <span class="n">x</span> <span class="err">→</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">))</span>
</span><span class="line">
</span><span class="line"><span class="nf">sumsqs</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">sumsqs</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">fold</span> <span class="p">(</span><span class="n">listsqs</span> <span class="n">n</span><span class="p">)</span> <span class="n">by</span> <span class="kr">_</span><span class="o">+</span><span class="kr">_</span> <span class="n">from</span> <span class="n">zero</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In the Agda mode of emacs, we can evaluate , for example, the sum of squares up to $20$ to get $2870$. This illustrates that what we are doing does include general purpose programming - indeed it implements an older model of computing, due to Church, which is equivalent to what may be more familiar models.</p>

<h3 id="finding-and-option-types">Finding and option types.</h3>

<p>We next define a function that finds an element in a list (of type $A$) having a given property. However the list may have no such element, so we cannot always return an object in $A$. Simply giving an error is meaningless mathematically and a bad idea for a program.</p>

<p>To deal with such a situation, we use the type $Option A$, whose objects are $Some\ a$ for objects $a$ of type $A$, and an object $None$ representing no result.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Option types</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Option</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="kt">Some</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Option</span> <span class="kt">A</span>
</span><span class="line">  <span class="kt">None</span> <span class="kt">:</span> <span class="kt">Option</span> <span class="kt">A</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can now define a find function, returning an option type, containing an object in the list with the given property if there is such an object.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>finding in a list</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_find_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span> <span class="err">→</span> <span class="p">(</span><span class="kt">A</span> <span class="err">→</span> <span class="kt">Bool</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Option</span> <span class="kt">A</span>
</span><span class="line"><span class="kt">[]</span> <span class="n">find</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">None</span>
</span><span class="line"><span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="n">xs</span><span class="p">)</span> <span class="n">find</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">if</span> <span class="p">(</span><span class="n">p</span> <span class="n">x</span><span class="p">)</span> <span class="kr">then</span> <span class="p">(</span><span class="kt">Some</span> <span class="n">x</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="n">xs</span> <span class="n">find</span> <span class="n">p</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Thus, using option types, we can represent partially defined functions - those defined on some objects of a type $A$. One often encounters partial functions - finding in a list, taking square-roots, division (avoiding division by $0$), etc.
We can <em>lift</em> such a partially defined function to one taking values in an option type. We shall identify partial functions with their lifts.</p>

<p>Suppose we have a partially defined function $f: A\to B$ (not defined on some values of $A$ in general) and a function $g : B \to C$ (defined everywhere). Then it is natural to define the composition of $f$ and $g$ as a partial function defined wherever $f$ is defined. Passing to lifts, this is accomplished by the map function on option types.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>map on an option type</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_mapOption_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Option</span> <span class="kt">A</span> <span class="err">→</span> <span class="p">(</span><span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Option</span> <span class="kt">B</span>
</span><span class="line"><span class="kt">None</span> <span class="n">mapOption</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">None</span>
</span><span class="line"><span class="p">(</span><span class="kt">Some</span> <span class="n">a</span><span class="p">)</span> <span class="n">mapOption</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">Some</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Even better, if both $f: A\to B$ and $g : B\to C$ are both partially defined, we can compose them to get a value in $C$ exactly for elements $a : A$ for which $f(a)$ is defined and lies in the domain of g. We do this  by flatmapping (after passing to lifts once more).</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>flatmap on option types</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_flatMapOption_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Option</span> <span class="kt">A</span> <span class="err">→</span> <span class="p">(</span><span class="kt">A</span> <span class="err">→</span>  <span class="kt">Option</span> <span class="kt">B</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Option</span> <span class="kt">B</span>
</span><span class="line"><span class="kt">None</span> <span class="n">flatMapOption</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">None</span>
</span><span class="line"><span class="p">(</span><span class="kt">Some</span> <span class="n">a</span><span class="p">)</span> <span class="n">flatMapOption</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>There are some obvious common features between lists and option types.</p>

<ul>
  <li>They are both parametrized by a single type A.</li>
  <li>The type A itself can be embedded in these: map $a$ to the list $a :: []$ in $List\ A$ and the object $Some\ a$ in $Option\ A$, respectively.</li>
  <li>We can map elements of these types, given a function with domain $A$.</li>
  <li>Given a function with domain $A$ and codomain of the form $List\ B$ or $Option\ B$ as appropriate, we can flatmap to get an object of type $List\ C$ or $Option\ C$, respectively.</li>
</ul>

<p>Types that have these properties (and some consistency relations between the embeddings, map and flatmap) are called Monadic. There are many other useful such types, for example $Future\ A$ is used to represent an object of type $A$ that will be available in the future, for instance after a long computation. We do not have to wait for the computation to be over before saying what to do with the result when available, even if this involves another long computation which will return a result as a Future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inductive Types: Natural Numbers, Lists]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2015/01/08/inductive-types-natural-numbers/"/>
    <updated>2015-01-08T09:03:29+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2015/01/08/inductive-types-natural-numbers</id>
    <content type="html"><![CDATA[<p>Booleans were a finite type, where we specified all constant objects of the type. More generally, we can construct inductive types by introducing constructors - functions mapping to the type. For instance, we can define the natural numbers (which in logic generally start with $0$).</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Natural Numbers: Inductive Definition</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="err">ℕ</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">zero</span> <span class="kt">:</span> <span class="err">ℕ</span>
</span><span class="line">  <span class="n">succ</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Here $zero$ is $0$ and $succ$ is the function taking any natural number to its successor. Any natural number can be built from these, and different expressions give different numbers. However, as with the case of Booleans, we do not have any explicit rules giving such statements  - indeed, it would be quite painful to formulate such rules, as we have to define expressions, equality of expressions etc. Instead, the rules for defining functions from natural numbers implicitly contain such statements. We define functions on natural numbers by pattern matching, but this time the patterns can involve the constructors.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Addition of natural numbers</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">_</span><span class="o">+</span><span class="kr">_</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">zero</span> <span class="o">+</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span>
</span><span class="line"><span class="p">(</span><span class="n">succ</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">succ</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The left hand sides pattern match on the constructors for natural numbers. Notice that this is a recursive definition, the right hand side in the second pattern for defining addition also involves addition. This is fine as the definition lets us rewrite a sum in terms of sums of simpler terms, and such a process eventually terminates. However, we can write nonsensical definitions in general.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Recursion resulting in infinite loops</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">forever</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">forever</span> <span class="n">zero</span> <span class="ow">=</span> <span class="n">zero</span>
</span><span class="line"><span class="nf">forever</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">forever</span> <span class="p">(</span><span class="n">succ</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>When we try to compute $forever(1)$ (where $1 = succ (zero)$), we get that $forever(1) = forever(2)$, and this continues forever. Fortunately, Agda will not let us make such definitions. This does come at a price though - sometimes it takes a lot of work to convince Agda that functions terminate. There are deeper, conceptual limitations to any system ensuring termination, as discovered by Turing, which we return to in the future.</p>

<p>In homotopy type theory, the rules for such recursive definitions are nicely formulated so we cannot making nonsensical definitions. We shall see how this is done much later. We now define a couple of other recursive functions.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Multiplication of natural numbers</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">_</span><span class="o">*</span><span class="kr">_</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">zero</span> <span class="o">*</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">zero</span>
</span><span class="line"><span class="p">(</span><span class="n">succ</span> <span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Factorials</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">factorial</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">factorial</span> <span class="n">zero</span> <span class="ow">=</span> <span class="n">succ</span> <span class="n">zero</span>
</span><span class="line"><span class="nf">factorial</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">factorial</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Our constructors are unfortunately only as efficient as tally marks in dealing with actual numbers. Agda has a built in type that lets us deal with natural numbers the usual way. We can invoke it as below.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Agda: Builtin natural numbers</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="cm">{-# BUILTIN NATURAL ℕ #-}</span>
</span><span class="line"><span class="cm">{-# BUILTIN ZERO zero #-}</span>
</span><span class="line"><span class="cm">{-# BUILTIN SUC succ #-}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>Note</strong>:  If you are using the latest version of Agda (2.4.2.2),  it is enough to include this line <code>{-# BUILTIN NATURAL ℕ #-}</code>  </p>

<h3 id="exercise">Exercise</h3>

<p>Complete the following definitions of the square of a natural number, using the addition but <strong>not</strong> the multiplication of natural numbers.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">sq</span><span class="err">₀</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">sq</span><span class="err">₀</span> <span class="n">zero</span> <span class="ow">=</span>
</span><span class="line"><span class="nf">sq</span><span class="err">₀</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Complete the following definitions of the square of a natural number. You may use the addition and multiplication of natural numbers.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">sq</span><span class="err">₁</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">sq</span><span class="err">₁</span> <span class="ow">=</span> <span class="err">λ</span> <span class="n">n</span> <span class="err">→</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1 id="lists--a-parametrized-type">Lists : A parametrized type</h1>

<p>We shall now define the type of Lists of objects, each of which is of a given type A. Thus, we are defining not just one type, but a family of types parametrized by the type A.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Lists</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="kt">[]</span> <span class="kt">:</span> <span class="kt">List</span> <span class="kt">A</span>
</span><span class="line">  <span class="kr">_</span><span class="ow">::</span><span class="kr">_</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The constructor $[]$ is just a constant, giving us the empty list. The constructor $ \_ :: \_ $ gives a list from an element $a$ in $A$ and a list $l$ of elements in $A$ by adding $a$ to the beginning of the list $l$. For instance (after importing the natural numbers constructed earlier) we can describe the list [1, 2, 3] as</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>The list [1, 2, 3]</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">open</span> <span class="kr">import</span> <span class="nn">Nat</span>
</span><span class="line">
</span><span class="line"><span class="nf">onetwothree</span> <span class="kt">:</span> <span class="kt">List</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">onetwothree</span> <span class="ow">=</span> <span class="mi">1</span> <span class="ow">::</span> <span class="p">(</span><span class="mi">2</span> <span class="ow">::</span> <span class="p">(</span><span class="mi">3</span> <span class="ow">::</span> <span class="kt">[]</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can make things a little cleaner by specifying that $\<em>::\</em>$ is right associative. We shall discuss this later. Let us now define the length of a list. Here is our first definition.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Length of a list: First attempt</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">length</span><span class="err">₀</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">length</span><span class="err">₀</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">zero</span>
</span><span class="line"><span class="nf">length</span><span class="err">₀</span> <span class="kt">A</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">l</span><span class="p">)</span> <span class="ow">=</span> <span class="n">succ</span> <span class="p">(</span><span class="n">length</span><span class="err">₀</span> <span class="kt">A</span> <span class="n">l</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We have given a recursive definition. We defined a function of the type $A$ as well as the list, as we needed $A$ in the right hand side of the second pattern. But $A$ can be inferred in this pattern - it is the type of the element $a$. So we can declare $A$ to be an optional argument (by putting it in braces), and let Agda infer its value. This gives us a cleaner definition.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Length of a list</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">length</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">length</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">zero</span>
</span><span class="line"><span class="nf">length</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">l</span><span class="p">)</span> <span class="ow">=</span> <span class="n">succ</span> <span class="p">(</span><span class="n">length</span> <span class="n">l</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Next, we define some functions recursively. The first is concatentation, which combines two lists by giving the entries of the first followed by those of the second.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Concatenation of Lists</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">_</span><span class="o">++</span><span class="kr">_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span>
</span><span class="line"><span class="kt">[]</span> <span class="o">++</span> <span class="n">l</span> <span class="ow">=</span> <span class="n">l</span>
</span><span class="line"><span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">xs</span><span class="p">)</span> <span class="o">++</span> <span class="n">l</span> <span class="ow">=</span> <span class="n">a</span> <span class="ow">::</span> <span class="p">(</span><span class="n">xs</span> <span class="o">++</span> <span class="n">l</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We next define the function that reverses a list.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Reversing a list</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">reverse</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span>
</span><span class="line"><span class="nf">reverse</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class="line"><span class="nf">reverse</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">l</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">reverse</span> <span class="n">l</span><span class="p">)</span> <span class="o">++</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="kt">[]</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We now turn to some more interesting functions. Given a list of objects of type $A$ and a function $f:A \to B$, we can apply $f$ to each entry of the list to get a list of elements of $B$. This is usually called the $map$ function.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>map function on lists</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_map_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span> <span class="err">→</span> <span class="p">(</span><span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span><span class="p">)</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">B</span>
</span><span class="line"><span class="kt">[]</span> <span class="n">map</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class="line"><span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">xs</span><span class="p">)</span> <span class="n">map</span> <span class="n">f</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">xs</span> <span class="n">map</span> <span class="n">f</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can do more - if we have a function $f: A \to List\ B$, then we can map a list $l$ of elements of $A$ to a list of elements of $B$ - each element of $l$ maps to a list of elements of $B$, and we get a list by concatenating these lists together.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>flatmap on lists</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_flatMap_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">A</span> <span class="err">→</span> <span class="p">(</span><span class="kt">A</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">B</span><span class="p">)</span> <span class="err">→</span> <span class="kt">List</span> <span class="kt">B</span>
</span><span class="line"><span class="kt">[]</span> <span class="n">flatMap</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class="line"><span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="n">xs</span><span class="p">)</span> <span class="n">flatMap</span> <span class="n">f</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="o">++</span> <span class="p">(</span><span class="n">xs</span> <span class="n">flatMap</span> <span class="n">f</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In case you did not notice, we have been programming in a functional language. To those used to imperative languages (say C), this may not look like programming, but programming in functional languages is essentially building functions, collections and structures. Indeed anyone who has programmed in (for example) scala for a while hungers for a flatmap function. We will next see some of the other main ingredients of collections in functional languages - finding in, filtering and folding lists. </p>

<h3 id="exercises">Exercises</h3>

<ul>
  <li>Define a function <strong>fill</strong> which, given a type $A$ (implicitly), an element $a : A$ and a natural number $n$, gives a list of length $n$ all of whose entries are $a$.</li>
  <li>Define a Boolean valued function <strong>empty</strong> on lists giving whether a list is empty.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notation for Universes]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2015/01/07/notation-for-universes/"/>
    <updated>2015-01-07T09:25:59+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2015/01/07/notation-for-universes</id>
    <content type="html"><![CDATA[<p>Agda uses the notation <strong>Set</strong> for the first universe. This is incorrect from the point of view of Homotopy type theory, as not all types in this universe are sets. Following HoTT-Agda, we shall denote this instead as <strong>Type</strong>. We accordingly modify the definition of Booleans.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kt">Type</span> <span class="kt">:</span> <span class="kt">Set</span><span class="err">₁</span>
</span><span class="line"><span class="kt">Type</span> <span class="ow">=</span> <span class="kt">Set</span>
</span><span class="line">
</span><span class="line"><span class="kr">data</span> <span class="kt">Bool</span> <span class="kt">:</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">true</span>   <span class="kt">:</span> <span class="kt">Bool</span>
</span><span class="line">  <span class="n">false</span>  <span class="kt">:</span> <span class="kt">Bool</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The statement <strong>Bool : Type</strong> should be read as saying that <strong>Bool</strong> has type <strong>Type</strong>, which implies in particular that it is a type. This is analogous to an expression like <strong>3 : Int</strong> in a programming language, which says that <strong>3</strong> is an integer.</p>

<p>Note that <strong>Type</strong> itself has to have type in a higher universe to avoid Russel’s paradox. Agda (like HoTT) has a hierarchy of such universes, $Set = Set_0$, $Set_1$ etc.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Foundations: Mathematical Objects, Types, Rules]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2015/01/06/foundations-objects/"/>
    <updated>2015-01-06T09:25:57+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2015/01/06/foundations-objects</id>
    <content type="html"><![CDATA[<p>Quoth Andrej Bauer:</p>

<blockquote>
  <p>Mathematicians like to imagine that their papers could in principle be formalized in set theory. This gives them a feeling of security, not unlike the one experienced by a devout man entering a venerable cathedral. It is a form of faith professed by logicians. Homotopy Type Theory is an alternative foundation to set theory.</p>
</blockquote>

<p>We now turn to the basics of homotopy type theory. We begin by laying out the basic rules governing such foundations.</p>

<p>We regard almost everything in mathematics as an object - not just numbers or groups, but even theorems, proofs, axioms, constructions etc.  This lets us consider functions acting on, and collections of, just about everything. Formally objects are called <em>terms</em>, based on standard terminology of logic, but it is best to think of <em>term</em> as a synonym for <em>mathematical object</em>.</p>

<p>Every term has a type, which is generally (but not always) unique. Types themselves are terms, so in particular have types. A type whose objects are themselves types is called a universe. Every set is a type, but not all types are sets.</p>

<p>Our foundations are governed by rules telling us the ways in which we can construct terms, which we will see as we go on. Further, we have rules letting us make two types of judgements:</p>

<ul>
  <li>that an object $x$ has a type $T$ (denoted $x : T$).</li>
  <li>that two objects $x$ and $y$ are equal by definition.</li>
</ul>

<p>Objects may be equal even if they are not so by definition. For instance, for a real number x, we have the equality</p>

<script type="math/tex; mode=display">sin^2(x) + cos^2(x) =1</script>

<p>which it would be silly to say is true by definition. Rather, it is a proposition that it is true, and we say the two sides of these are propositionally equal (but not definitionally or judgementally equal). Similar considerations also apply to objects having specified types.</p>

<p>In addition to constructing objects by our rules, we can introduce objects and make some judgements related to them as axioms. Axioms may of course introduce inconsistencies.</p>

<h3 id="the-boolean-type">The Boolean type</h3>

<p>Let us begin constructing some mathematical objects. We shall do this in the language/formal proof system Agda, but I will try to be self-contained.</p>

<p>We start with a built in universe called Set - objects having type Set are sets. We shall use the <strong>data</strong> statement to construct the type of Booleans - which is a basic logical type used to represent whether a statement is true or false.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>The Boolean type</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Bool</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">true</span>   <span class="kt">:</span> <span class="kt">Bool</span>
</span><span class="line">  <span class="n">false</span>  <span class="kt">:</span> <span class="kt">Bool</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The above code gives the construction of three objects: a type called Bool and two objects true and false that have type Bool. This is a simple rule for constructing a type - give it a name and list objects in it. Such a rule, in both Agda and Homotopy type theory (HoTT) is a special case of a more general rule (for constructing inductive types) which we will see later.</p>

<p>Note that we do not have an explicit rule saying that any term with type Bool is either <em>true</em> or <em>false</em>, or even that <em>true</em> and <em>false</em> are not equal. Indeed we will not introduce any such rule; instead rules for constructing objects will implicitly tell us that there are exactly two distinct terms with type Bool, true and false.</p>

<h3 id="a-function">A function</h3>

<p>A central role in type theory is played by function types - one may even say that the principal virtue of type theory is treating functions with the respect they deserve (as any good programming language does), instead of trying to wrap them up as subsets of cartesian products that happen to satisfy some properties. We now define our first function, and our first function type.</p>

<p>Given types A and B, functions from A to B give a type</p>

<script type="math/tex; mode=display">A \to B.</script>

<p>We construct the function $not$ from Booleans to Booleans, which is the logical negation.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Logical Not function</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">not</span> <span class="kt">:</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</span><span class="line"><span class="nf">not</span> <span class="n">true</span> <span class="ow">=</span> <span class="n">false</span>
</span><span class="line"><span class="nf">not</span> <span class="n">false</span> <span class="ow">=</span> <span class="n">true</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We have defined the function <em>not</em> by giving the values on each Boolean constant, and these values are constants. This is the simplest form of <em>pattern matching</em>.</p>

<p>Note that being able to construct such a function means $true$ and $false$ are distinct objects as promised.</p>

<h3 id="currying-functions">Currying functions</h3>

<p>Let us now turn to functions of two variables. By a trick due to the logician Haskell Curry, we do not have to introduce a new type. Instead, observe that if we have a function $f(x,y)$ of two variables (of types $A$ and $B$, taking values of type $C$), then for fixed $x$ we get a function of $y$ only</p>

<p>$f(x , \_ ) = y \mapsto f(x,y)$</p>

<p>so $f(x, \_ )$ has the type of functions from $B$ to $C$. Now viewing $f(x, \_)$ as a function of $x$, we get the curried form of $f$,</p>

<script type="math/tex; mode=display">x \mapsto (y \mapsto f(x,y))</script>

<p>which has type</p>

<script type="math/tex; mode=display">A \to B \to C = A \to (B \to C).</script>

<p>We next define the logical <em>and</em> (in its curried form). A convenient Agda feature is that we can define functions so that their arguments can appear in the beginning, end, middle or any other combination, just by putting underscores as placeholders.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Logical And function</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">_</span><span class="o">&amp;</span><span class="kr">_</span> <span class="kt">:</span> <span class="kt">Bool</span> <span class="err">→</span> <span class="kt">Bool</span> <span class="err">→</span> <span class="kt">Bool</span>
</span><span class="line"><span class="nf">true</span> <span class="o">&amp;</span> <span class="n">true</span> <span class="ow">=</span> <span class="n">true</span>
</span><span class="line"><span class="nf">false</span> <span class="o">&amp;</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">false</span>
</span><span class="line"><span class="nf">true</span> <span class="o">&amp;</span> <span class="n">false</span> <span class="ow">=</span> <span class="n">false</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The definition is a small extension of pattern matching we used in defining not. If some argument does not affect the result, we can use an underscore to represent all cases.</p>

<h3 id="function-application">Function application</h3>

<p>So far we have defined functions by defining their values on each constant as a constant. In general we use variables to represent arguments, and the values are built from previously constructed terms and the variables. Here is an example.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>A function using function application</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">notnot</span> <span class="kt">:</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</span><span class="line"><span class="nf">notnot</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">not</span> <span class="n">x</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We used a variable for the argument of the function, another generalization of pattern matching. The right hand side was built from previously constructed terms using function application. Namely, a function $f$ from $A$ to $B$ can be applied to an object with type $A$ to get an object $f(a)$ with type $B$.</p>

<h3 id="lambda-expressions-giving-functions">Lambda: Expressions giving functions</h3>

<p>Functions can be specified by describing the image of each argument. These are given by λ-expressions, following the notation of Church’s λ-calculus. We define such a function, $verytrue$, below, by equating it with an anonymous function that forms the right hand side.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>A function using lambda</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">verytrue</span> <span class="kt">:</span> <span class="kt">Bool</span> <span class="err">→</span> <span class="kt">Bool</span>
</span><span class="line"><span class="nf">verytrue</span> <span class="ow">=</span> <span class="err">λ</span> <span class="n">x</span> <span class="err">→</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can define (curried) functions of more than one variable using λ-expressions without having to explicitly nest λs.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Logical &#8220;exclusive or&#8221; : nested lambdas</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_xor_</span> <span class="kt">:</span> <span class="kt">Bool</span> <span class="err">→</span> <span class="kt">Bool</span> <span class="err">→</span> <span class="kt">Bool</span>
</span><span class="line"><span class="nf">_xor_</span> <span class="ow">=</span> <span class="err">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="err">→</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">not</span> <span class="n">y</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="n">not</span> <span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We have now seen the most basic constructions of types and mathematical terms. We shall next turn to the more powerful constructions - inductive types and dependent types.</p>

<h2 id="exercise">Exercise:</h2>
<p>Complete the following three definitions of the logical <em>nand</em> function (look up definition if it is not familiar). Note that subscripts in Agda are obtained by typing, for example, <strong>nand\_0</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">nand</span><span class="err">₀</span> <span class="kt">:</span> <span class="kt">Bool</span> <span class="err">→</span> <span class="kt">Bool</span> <span class="err">→</span> <span class="kt">Bool</span>
</span><span class="line"><span class="nf">nand</span><span class="err">₀</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span>
</span><span class="line">
</span><span class="line"><span class="nf">nand</span><span class="err">₁</span> <span class="kt">:</span> <span class="kt">Bool</span> <span class="err">→</span> <span class="kt">Bool</span> <span class="err">→</span> <span class="kt">Bool</span>
</span><span class="line"><span class="nf">nand</span><span class="err">₁</span> <span class="n">true</span> <span class="n">true</span> <span class="ow">=</span>
</span><span class="line">
</span><span class="line"><span class="nf">nand</span><span class="err">₂</span> <span class="kt">:</span> <span class="kt">Bool</span> <span class="err">→</span> <span class="kt">Bool</span> <span class="err">→</span> <span class="kt">Bool</span>
</span><span class="line"><span class="nf">nand</span><span class="err">₂</span> <span class="ow">=</span> <span class="err">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="err">→</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Types and First-order Languages]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2015/01/04/types-and-first-order-languages/"/>
    <updated>2015-01-04T13:25:39+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2015/01/04/types-and-first-order-languages</id>
    <content type="html"><![CDATA[<h2 id="grammar">Grammar</h2>

<p>A first-order languages has words and phrases (expressions) belonging to four types/type families.</p>

<ul>
  <li>term</li>
  <li>formula</li>
  <li>function - determined by degree</li>
  <li>predicate - determined by degree.</li>
</ul>

<p>Note that the last two types can only have words as members, i.e., we cannot create elements of these types. So for a fixed language, there are only a fixed number of types. Usually functions and predicates have degrees $1$ or $2$, so there are only about $6$ types of expressions.</p>

<h2 id="formation-rules">Formation rules.</h2>

<p>The formation rule for new phrases are entirely in terms of the types of its constituent words/phrases, and there are typically only about $6$ such types. This means the language is not very <em>expressive</em>.</p>

<h2 id="consequences-of-low-expressiveness">Consequences of low expressiveness</h2>

<p>Depending on ones objective, there are two ways to cope with lack of expressiveness.</p>

<ul>
  <li>In <em>weakly typed</em> or <em>dynamically typed</em> programming languages, a lot of expressions are permitted (at compile time, or even run time) but lead to errors.</li>
  <li>In mathematics, one embeds actually mathematics in the not very expressive language of set theory paying the price of being verbose and opaque.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sets and Types]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2014/12/29/sets-and-types/"/>
    <updated>2014-12-29T13:29:36+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2014/12/29/sets-and-types</id>
    <content type="html"><![CDATA[<h2 id="set-theory">Set theory</h2>

<p>A <em>set</em> is a collection of objects with no further structure. Thus, the only property (or function) associated with a set $S$ is <em>membership</em> - a different object $x$ may or may not belong to $S$ (denoted as usual $x\in S$).</p>

<p>It is natural to try to reverse this and consider, for any property of objects (for example sets) the set that consists of those satisfying this (for example all sets that have a certain property). Cantor discovered, however, that this leads to paradoxes. For instance, Russell’s paradox appears if we consider the set $ S = \{X : X \notin X\}.$</p>

<p>We ask whether $S\in S$. By the definition of $S$, if $X\in X$, then $X\notin X$ and vice versa.</p>

<p>To prevent such paradoxes, we cannot allow sets to be defined by arbitrary properties. We do of course see definitions that look very similar to the above in mathematics - these are definitions of <em>subsets</em> of a given set. Indeed one of the valid ways of defining a set is to consider the elements of a given set that satisfy some property.</p>

<p>Clearly defining only subsets of pre-existing sets will not get us far. Instead, set theory is formulated in terms of axioms, many of which assert the existence of various sets. For instance, if $S$ is a set then there is an axiom asserting the existence of the <em>power set</em> of $S$, whose elements are subsets of $S$. Sometimes we need to consider collections, such as that consisting of all groups, that are so large that they cannot be treated as sets but are considered <em>classes</em> instead.</p>

<h2 id="foundations-using-set-theory">Foundations using set theory</h2>

<p>Sets (and classes) form the objects in the usual foundations of mathematics, analogous to the vocabulary of the language of mathematics. However to describe theorems, proofs, or even properties describing sets, we need rules telling us how to form <em>terms</em> - corresponding to sets that may depend on variables, as well as <em>formulas</em> - corresponding to properties. We also need to specify the rules of deduction by which we can show that a theorem (given by a formula) is true. Standard foundations are the rules of <em>predicate calculus</em>.</p>

<p>These foundations can indeed express, or rather encode, all real mathematics. But this encoding is often very much longer than real life mathematics and are also opaque. If one actually expects to fully formalize mathematics, it is better to use some form of <em>type theory</em>.</p>

<h2 id="type-theory">Type theory</h2>

<p>In type theory we replace sets by types, and the notion of membership $x\in S$, $x$ belongs to the set $S$, by having an appropriate type $x : T$, i.e., $x$ has type $T$. The crucial difference is that objects of a given type $T$ (unlike elements of a set $S$) are expected to be of the same nature. For instance, the a typical type is $\mathbb{N}\to \mathbb{N}$, consisting of functions from $\mathbb{N}$ to $\mathbb{N}$.</p>

<p>Thus, for example $f : \mathbb{N}\to \mathbb{N}$ gives a lot of information about $f$. In particular we know that if $a : \mathbb{N}$, it is meaningful to talk of $f(a)$ and that this  is  a natural number too. Typically types allow us to restrict which expressions are meaningful, and infer the type of a meaningful expression. Such information is very useful in programming languages (where it is called type checking) - not only revealing errors without running a program (i.e., at compile time) but allowing a detailed analysis of the program which is used by tools.</p>

<p>In practical programming languages, type checking may be more or less strict - with stricter checking meaning that expressions that can cause error while running being more likely to be rejected at compile time itself. Some languages will treat an expression $f(a)$ as valid as long as $f$ is a function, and only give an error if $a$ has type different from the domain of $f$ when we actually try to compute this expression, while stricter  languages will reject such expression  unless the types match. However in practical code a function $f(x, y) = x/y$ will generally be regarded at best as a function of two real variables, with the compiler not checking that $y$ is non-zero.</p>

<p>There is another more conceptual choice in the form of type theory considered - whether or not to allow sub-typing. For instance, we can either regard every natural number as a rational number, or work with  the canonical inclusion that takes a natural number $n$  to the rational number $n/1$.</p>

<h2 id="types-as-spaces">Types as spaces</h2>

<p>With  all these choices, type theory  is a very fragmented subject, with both practical engineering considerations and whims dictating the many choices. It is clear to a large extend what behaviour we expect from sets, and this anchors our axiomatization. Traditionally type theory is not constrained in such a manner.</p>

<p>Homotopy type theory is born out of an observed deep connection between (a form of) type theory and topology. Thus behaviour that we  expect from topology guides our  choices, so we can hope for  coherent standard foundations. We shall see that this connection is indeed extremely fruitful. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language, Logic, Types]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2014/12/17/language/"/>
    <updated>2014-12-17T13:58:05+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2014/12/17/language</id>
    <content type="html"><![CDATA[<h3 id="recursive-structures">Recursive structures</h3>

<p>A sentence is made of phrases, which in turn are made of words, just as matter is made molecules, which are in turn made of atoms. Just as atoms are of different types (elements), words are of different types (parts of speech).</p>

<p>But there is a crucial difference. A typical sentence consists of a <em>verb phrase</em> and a <em>noun phrase</em>. These may be single words - verbs or nouns, but can also be built from words and phrases, including verb phrases and noun phrases. Thus phrases are <strong>recursive</strong> - they can be built from other phrases of the same type. This gives language a richness that is absent in <strong>hierarchical</strong> structures such as matter, where each level is built from simpler structures.</p>

<p>It is this richness of language that makes it a natural model for logic, and much of formal logic was traditionally modeled on language. We see this briefly in the case of first order logic, before turning to an overview of how and why to go beyond this.</p>

<h3 id="first-order-logic">First order logic</h3>

<p>First-order logic is based on a language with words being <em>variables</em>, <em>constants</em>, <em>functions</em>, <em>relations</em> (predicates),  <em>quantifiers</em>, <em>logical operations</em>. There are two types of phrases - <strong>terms</strong> and <strong>formulas</strong>, which are built out of these words. Terms can be single words - constants or variables, or can be built by applying a function to the appropriate number of terms; formulas can be built from terms. This is very similar to a formal grammar for a language.</p>

<p>Traditional foundations of mathematics are based on <em>first order logic</em> giving the grammar - i.e., rules for constructing terms, formulas, proofs etc., with the vocabulary of <em>set theory</em>. This has proved sufficient to work consistently. Yet there are serious limitations.</p>

<p>We can build functions by applying functions to terms, but not to other functions (functions are not terms). This means that we cannot naturally express functions of functions, such as the norm of a linear transformation. A naive approach will be to simply treat functions as terms, and allow expressions like $f(f)$, but this leads to paradoxes.</p>

<p>In set theory the approach taken  is to use indirect descriptions - functions as relations, which are sets of pairs. This is fine in terms of issues like paradoxes and consistency, but results in formalizations of actual mathematics being absurdly verbose and bearing hardly any resemblance to real mathematics.</p>

<h3 id="type-theory">Type theory</h3>

<p>While terms in first-order logic, like phrases in a language, can be built recursively, the <em>types</em> of words, like the part of speech, are a fixed finite set - variables, constants, functions, quantifiers etc. In particular there is no type representing functions from a given type to another given type. In <em>type theory</em>, we allow not only terms but their types to be recursively generated, with rules telling us how to construct both terms and types, and how to determine the type of a term.</p>

<p>There are many flavours of type theory. It was discovered by Curry and Howard that <em>dependent type theory</em> contains not only set theory but the usual rules of reasoning, making for very efficient and elegant foundations. We shall study a flavour of dependent type theory due to Per Martin-Löf, which turns out to have remarkable connections to topology.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Welcome to the Course: Logic, Types, Spaces]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2014/12/12/welcome-to-the-course-logic/"/>
    <updated>2014-12-12T14:05:52+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2014/12/12/welcome-to-the-course-logic</id>
    <content type="html"><![CDATA[<p>The course <strong>Ma 210: Logic, Types and Spaces</strong> will start in January 2015. For a description and related resources, please visit the <a href="http://siddhartha-gadgil.github.io//github/home/">course home page</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Logic From Types]]></title>
    <link href="http://siddhartha-gadgil.github.io//github/blog/2014/03/26/logic-from-types/"/>
    <updated>2014-03-26T06:46:59+05:30</updated>
    <id>http://siddhartha-gadgil.github.io//github/blog/2014/03/26/logic-from-types</id>
    <content type="html"><![CDATA[<p>At the core of homotopy type theory (and its predecessors) is the idea of <em>propostions as types</em>. Namely, we interpret logical propositions - statements that are either true or false, as types, with a proposition being true if and only if the corresponding type has an element (i.e., there is an object with that type). The Curry-Howard correspondence lets us embed all of logic into type theory in the manner.</p>

<h3 id="true-and-false">True and False</h3>

<p>We begin by representing the two simplest propositions: true - always true,  and false.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>True and False types</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">True</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">qed</span> <span class="kt">:</span> <span class="kt">True</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="kr">data</span> <span class="kt">False</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The $True$ type has just one constructor, giving an object with type $True$. On the other hand, the $False$ type has no constructors, so there are no objects of type $False$.</p>

<p>There are various ways of building propositions from other propositions. We see how these translate to constructions of types.</p>

<h3 id="logical-implies">Logical implies</h3>

<p>If $P$ and $Q$ are propositions, which we identify with their corresponding types. We interpret the proposition $P \implies Q$ as the function type $P \to Q$.</p>

<h3 id="some-deductions">Some deductions</h3>

<p><em>Modus Ponens</em> is the rule of deduction (due to Aristotle) that says that if the proposition $P$ is true, and $P$ implies $Q$, then $Q$ is true. We can prove this in the types interpretation. Namely, Modus Ponens transaltes to the statement that if we have an objects of type $P$ and $P \to Q$, then we have an object of type $Q$. We get an object of type $Q$ by function application.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Modus Ponens</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">modusponens</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">P</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="kt">Q</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">P</span> <span class="err">→</span> <span class="p">(</span><span class="kt">P</span> <span class="err">→</span> <span class="kt">Q</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Q</span>
</span><span class="line"><span class="nf">modusponens</span> <span class="n">p</span> <span class="n">imp</span> <span class="ow">=</span> <span class="n">imp</span> <span class="n">p</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Next, we see my favourite method of proof - vacuous implication. This says that a false statement implies everything, i.e., for any proposition $P$, we have $False \implies P$, which in type theory says $False\to P$ has objects.</p>

<p>As the $False$ type has no cases at all, a function is defined on $False$ by using an absurd pattern, which just says that there are no cases, so no definition is needed.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Vacuous implication</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">vacuous</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">False</span> <span class="err">→</span> <span class="kt">A</span>
</span><span class="line"><span class="nf">vacuous</span> <span class="nb">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="even-and-odd-numbers">Even and Odd numbers</h3>

<p>Next, we define a type family Even n which is non-empty if and only if n is even. To do this, we see that a number is even if and only if it is even as a consequence of the rules</p>

<ul>
  <li>$0$ is even.</li>
  <li>If $n$ is even, so is $n + 2$.
*
Thus, we can define the inductive type family:</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Even type family</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Even</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">zeroeven</span> <span class="kt">:</span> <span class="kt">Even</span> <span class="n">zero</span>
</span><span class="line">  <span class="o">+</span><span class="mi">2</span><span class="n">even</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Even</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Even</span> <span class="p">(</span><span class="n">succ</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can prove that $2$ is even by applying the second rule, with $n=0$, to the first rule (telling us that $0$ is even).</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>2 is Even</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="mi">2</span><span class="n">even</span> <span class="kt">:</span> <span class="kt">Even</span> <span class="mi">2</span>
</span><span class="line"><span class="mi">2</span><span class="n">even</span> <span class="ow">=</span> <span class="o">+</span><span class="mi">2</span><span class="n">even</span> <span class="n">zeroeven</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We next show that $1$ is odd. This means that we have to show that the type $Even 1$ is empty. While rules let us construct objects, and verify their types, there is no rule that tells us directly that a type is empty.</p>

<p>However, there is a nice way of capturing that a type $A$ is empty - if there is a function from $A$ to the empty type $False$, then $A$ must be empty - there is nowhere for an object of type $A$ to be mapped.</p>

<p>Indeed, what we prove is that there is a function from $Even\ 1$ to $False$ ; we define this using an absurd pattern.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>1 is odd</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="mi">1</span><span class="n">odd</span> <span class="kt">:</span> <span class="kt">Even</span> <span class="mi">1</span> <span class="err">→</span> <span class="kt">False</span>
</span><span class="line"><span class="mi">1</span><span class="n">odd</span> <span class="nb">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="the-identity-type">The identity type</h3>

<p>One of the most fundamental concepts in homotopy type theory is the identity type family, representing equality between objects with a given type. This is an inductive type family, generated by the reflexivity constructor giving an equality between an object and itself.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>The identity type</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kr">_</span><span class="o">==</span><span class="kr">_</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">refl</span> <span class="kt">:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="n">a</span> <span class="o">==</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Note that while this is an inductive type family, for a fixed object a the type $a==a$ is <em>not</em> an inductive type defined by $refl(a)$, i.e., we cannot define (dependent) functions on this type but just defining them on the reflexivity constructor. This is a subtle point, which will become clearer as we look at the topological interpretation. We shall study the identity type extensively.</p>

<p>For now, let us show some basic properties of the identity type. All these are proved by constructing objects by pattern matching (recall that these are dependent functions, so we are formally constructing them by induction, not recursion).</p>

<p>Firstly, if $f$ is a function and $a==b$ (i.e., there is an object of type $a==b$), then $f(a)==f(b)$ (again, we mean there is an object of this type).</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Equality under function application</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">transfer</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">x</span> <span class="n">y</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span><span class="p">)</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="err">→</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span><span class="line"><span class="nf">transfer</span> <span class="n">f</span> <span class="p">(</span><span class="n">refl</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">refl</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Further, we see that equality (given by the identity type) is symmetric and transitive.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Symmetry of the equality</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">symm</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">x</span> <span class="n">y</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">}</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="err">→</span> <span class="n">y</span> <span class="o">==</span> <span class="n">x</span>
</span><span class="line"><span class="nf">symm</span> <span class="p">(</span><span class="n">refl</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">refl</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Transitivity of equality</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_transEq_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">}</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="err">→</span> <span class="n">y</span> <span class="o">==</span> <span class="n">z</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">z</span>
</span><span class="line"><span class="p">(</span><span class="n">refl</span> <span class="n">a</span><span class="p">)</span> <span class="n">transEq</span> <span class="p">(</span><span class="n">refl</span> <span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">refl</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>There is a new Agda feature we have used in the proof of transitivity: the <em>dot notation</em>. Notice that we have a term <strong>.a</strong> - this says that we can deduce, <em>from the types</em>, that $a$ is the only possibility at its position in the pattern.</p>

<h3 id="for-all">For all</h3>

<p>Suppose we have a type $A$ and a family of types $P(a)$ (which we regard as propositions), with a type associated to each object $a$ of type $A$. Then all the types $P(a)$ have objects  (i.e., all corresponding propositions are true) if and only if there is a dependent function mapping each object $a$ of type $A$ to an object of type  $P(a)$. Thus, the logical statement</p>

<script type="math/tex; mode=display">\forall a \in A\ P(a)</script>

<p>translates to the product type</p>

<script type="math/tex; mode=display">\prod\limits_{a : A} P(a).</script>

<p>In Agda, we represent the product type as $(a : A) \to P(a)$</p>

<h3 id="a-proof-by-induction">A proof by induction</h3>

<p>We can now prove a more substantial result. Namely, suppose we have a function $f : \Bbb{N}\to \Bbb{N}$ , and suppose for all $n\in \Bbb{N}$ we have $f(n) = f(n+1)$, then we show that, for all $n$, $f(n)=f(0)$.</p>

<p>Such a statement is normally proved by induction (indeed any proof must reduce to induction). We see that our pattern matching rules for constructing dependent functions suffice to prove this - this is why the dependent function that gives them is called the induction function.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>f(n)= f(n+1) for all n implies f is constant</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">constthm</span> <span class="kt">:</span> <span class="p">(</span><span class="n">f</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="p">((</span><span class="n">m</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">succ</span> <span class="n">m</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">f</span> <span class="n">m</span><span class="p">))</span> <span class="err">→</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">f</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line"><span class="nf">constthm</span> <span class="n">f</span> <span class="kr">_</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">refl</span> <span class="p">(</span><span class="n">f</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line"><span class="nf">constthm</span> <span class="n">f</span> <span class="n">adjEq</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">adjEq</span> <span class="n">n</span><span class="p">)</span> <span class="n">transEq</span> <span class="p">(</span><span class="n">constthm</span> <span class="n">f</span> <span class="n">adjEq</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Let us look at the statement and proof more carefully. Firstly, note that the statement is of the form</p>

<script type="math/tex; mode=display"> (f : \Bbb{N} \to \Bbb{N}) \to P(f) \to Q(f).</script>

<p>As we have seen, the first term is a translation of $\forall f : \Bbb{N} \to \Bbb{N}$, so the statement says that for all functions $f : \Bbb{N} \to \Bbb{N}$ (or any other codomain with obvious modifications), we have $P(f) \to Q(f)$.</p>

<p>This in turn is a translation of $P(f) \implies Q(f)$. So we can regard  $P(f)$ as the hypothesis, for a fixed function $f$,  and $Q(f)$  as the desired conclusion.</p>

<p>The hypothesis P(f) is the statement</p>

<script type="math/tex; mode=display"> (m : \Bbb{N}) \to f(m+1) == f(m)</script>

<p>which is just the statement that for all $m$, $f(m+1)=f(m)$.  Finally, the conclusion $Q(f)$ just says that $f(n)=f(o)$ for all $n$.</p>

<p>We now look at the proof. The two constructors correspond to the base case and the induction step. Here the base case is just $f(0)=f(0)$, which follows from reflexivity of equality.</p>

<p>The induction step is more complicated. We prove the result for $n+1$ assuming the result for $n$. The main hypothesis $\forall m, f(m+1) = f(m)$, is, by pattern matching, $adjEq$. The right hand side, which is the proof in the case of $n+1$, is obtained from:</p>

<ul>
  <li>The hypothesis for $n$,  giving $f(n+1) = f(n).$</li>
  <li>The induction hypothesis, which is the theorem we are proving applied to $n$, giving $f(n)=0.$</li>
  <li>Transitivity of equality.
*
The proof is obtained by applying the function corresponding to the transitivity of equality to the two objects corresponding to the other ingredients above.</li>
</ul>

<p>This proof is remarkable in many ways. First of all, note that this is no longer or more complicated than an informal proof. Further, note that we did not have to invoke the usual induction axiom schema, but instead just used the rules for constructing objects. Most significantly, as most of our types are inductive type (or type families), we get recursive definitions and inductive proofs in all these cases.</p>

<p>Indeed,  using recursive definitions for inductive types we get all so called <em>universal properties</em>. Furthermore, traditionally universal properties require a separate uniqueness statement. But recursion-induction is powerful enough to even give the uniqueness statements for universal properties. This means a great deal of mathematical sophistication (universal algebra, various aspects of category theory) are encapsulated in these simple functions.</p>

<h3 id="more-types-for-propositions">More types for propositions</h3>

<p>We now see the types corresponding to the other ways of combining propositions : and, or and there exists.</p>

<p>Firstly, if $A$ and $B$ are types corresponding to propositions, then there are objects with each of these types if and only if there is a pair $(a, b)$ of the pair type $A \times B$, which we define as follows.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Pair type</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kr">_</span><span class="err">×</span><span class="kr">_</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="p">[</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">]</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">×</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We have to use square brackets as parenthesis have a special meaning in Agda. Observe that there is a single constructor that takes as input an object in $A$ and an object in $B$. We regard the result as the pair.</p>

<p>Next, suppose $A$ and $B$ are types corresponding to propositions and we wish to construct a type corresponding to $A$ <em>or</em> $B$, then we require a type whose elements are elements of $A$ and elements of $B$, or more accurately the images of such elements under constructors. This is the direct sum type.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Direct Sum type</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kr">_</span><span class="err">⊕</span><span class="kr">_</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">i</span><span class="err">₁</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">⊕</span> <span class="kt">B</span>
</span><span class="line">  <span class="n">i</span><span class="err">₂</span> <span class="kt">:</span> <span class="kt">B</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">⊕</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Finally, if we are given a collection of types $B(a)$ for objects $a$ of type $A$, we construct the type corresponding to at least one of these types having an element, i.e., a <em>there exists</em> type.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Sigma type</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="err">Σ</span><span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="err">ι</span> <span class="kt">:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="kt">B</span> <span class="n">a</span> <span class="err">→</span> <span class="err">Σ</span> <span class="kt">A</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Notice that the constructor for this type has as input an element $a$ and an element of type $B(a)$. Such elements exist if and only if some $B(a)$ is non-empty, i.e., the corresponding proposition is true.</p>

<p>As we see, we can express all the usual mathematical statements using types built up using our basic constructions: inductive types, functions and dependent functions. We have also seen that the basic rules for constructing objects are powerful rules of deduction. However, there are some things they cannot deduce, for instance the statement (called the axiom of extensionality) that if $f, g: A\to B$ are function with $f(a)=g(a)$ for all $a \in A$, then $f=g$. Hence, we have to introduce this as a postulate - we just postulate that  there is an object (which we give a name) of a given type.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Axiom of Extensionality</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">postulate</span>
</span><span class="line">  <span class="n">extensionality</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">g</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span><span class="p">)</span> <span class="err">→</span> <span class="p">((</span><span class="n">x</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span> <span class="err">→</span> <span class="n">f</span> <span class="o">==</span> <span class="n">g</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can similarly introduce axioms specific to a domain, say Euclidean geometry, by postulating them in a module.</p>
]]></content>
  </entry>
  
</feed>
