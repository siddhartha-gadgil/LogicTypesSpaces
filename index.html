
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Logic, Types and Spaces</title>
  <meta name="author" content="Siddhartha Gadgil">

  
  <meta name="description" content="We have seen that functions should be regarded as equal if they are homotopic. As usual in mathematics, we have a corresponding notion of equivalence &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://siddhartha-gadgil.github.io//github">
  <link href="/LogicTypesSpaces/favicon.png" rel="icon">
  <link href="/LogicTypesSpaces/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Logic, Types and Spaces" type="application/atom+xml">
  <script src="/LogicTypesSpaces/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/LogicTypesSpaces/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-58114020-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="/LogicTypesSpaces/">Logic, Types and Spaces</a></h1>
  
    <h2>Towards homotopy type theory</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:siddhartha-gadgil.github.io//github" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/LogicTypesSpaces/home">Home</a></li>
  <li><a href="/LogicTypesSpaces/">Blog</a></li>
  <li><a href="/LogicTypesSpaces/blog/archives">Archives</a></li>
  <li><a href="/LogicTypesSpaces/blog/categories/exercises/">Exercises</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/LogicTypesSpaces/blog/2015/03/30/equivalence-of-types/">Equivalence of Types</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>We have seen that functions should be regarded as equal if they are <em>homotopic</em>. As usual in mathematics, we have a corresponding notion of equivalence between types, namely a function $f: A \to B$ is an equivalence if there is an inverse functions with compositions equal, i.e., homotopic, to the identity. However, if we naturally turn this into a type, the result (as we see below) is not well-behaved. So we call this relation <em>quasi-equivalence</em>.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">isQuasiEquiv</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">X</span> <span class="kt">Y</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="kt">X</span> <span class="err">→</span> <span class="kt">Y</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Type</span>
</span><span class="line"><span class="nf">isQuasiEquiv</span> <span class="p">{</span><span class="kt">X</span><span class="p">}</span> <span class="p">{</span><span class="kt">Y</span><span class="p">}</span> <span class="n">f</span> <span class="ow">=</span> <span class="err">Σ</span> <span class="p">(</span><span class="kt">Y</span> <span class="err">→</span> <span class="kt">X</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">g</span> <span class="err">→</span> <span class="p">((</span><span class="n">f</span> <span class="err">∘</span> <span class="n">g</span><span class="p">)</span> <span class="err">∼</span> <span class="p">(</span><span class="n">id</span> <span class="kt">Y</span><span class="p">))</span> <span class="err">×</span> <span class="p">((</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="p">)</span> <span class="err">∼</span> <span class="p">(</span><span class="n">id</span> <span class="kt">X</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Instead, we define $f$ to be an equivalence if it has separate left and right equivalences. As we see in Algebra, this is an equivalent condition. However, this is better behaved in that the proofs of the proposition as types is generally unique in this formulation.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">isEquiv</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">X</span> <span class="kt">Y</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="kt">X</span> <span class="err">→</span> <span class="kt">Y</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Type</span>
</span><span class="line"><span class="nf">isEquiv</span> <span class="p">{</span><span class="kt">X</span><span class="p">}</span> <span class="p">{</span><span class="kt">Y</span><span class="p">}</span> <span class="n">f</span> <span class="ow">=</span> <span class="err">Σ</span> <span class="p">(</span><span class="kt">Y</span> <span class="err">→</span> <span class="kt">X</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">h</span> <span class="err">→</span> <span class="err">Σ</span> <span class="p">(</span><span class="kt">Y</span> <span class="err">→</span> <span class="kt">X</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">g</span> <span class="err">→</span> <span class="p">((</span><span class="n">f</span> <span class="err">∘</span> <span class="n">g</span><span class="p">)</span> <span class="err">∼</span> <span class="p">(</span><span class="n">id</span> <span class="kt">Y</span><span class="p">))</span> <span class="err">×</span> <span class="p">((</span><span class="n">h</span> <span class="err">∘</span> <span class="n">f</span><span class="p">)</span> <span class="err">∼</span> <span class="p">(</span><span class="n">id</span> <span class="kt">X</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>## Exercise: Construct a function from $isEquiv(f)$ to $isQuasiEquiv(f)$.</p>

<h2 id="an-equivalence">An Equivalence</h2>

<p>The function $not: Bool \to Bool$ is an equivalence, with itself as an inverse.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">notnot</span><span class="o">~</span><span class="n">id</span> <span class="kt">:</span> <span class="p">(</span><span class="n">not</span> <span class="err">∘</span> <span class="n">not</span><span class="p">)</span> <span class="o">~</span> <span class="p">(</span><span class="n">id</span> <span class="kt">Bool</span><span class="p">)</span>
</span><span class="line"><span class="nf">notnot</span><span class="o">~</span><span class="n">id</span> <span class="n">true</span> <span class="ow">=</span> <span class="n">refl</span> <span class="n">true</span>
</span><span class="line"><span class="nf">notnot</span><span class="o">~</span><span class="n">id</span> <span class="n">false</span> <span class="ow">=</span> <span class="n">refl</span> <span class="n">false</span>
</span><span class="line">
</span><span class="line"><span class="nf">notIsEquiv</span> <span class="kt">:</span> <span class="n">isEquiv</span><span class="p">(</span><span class="n">not</span><span class="p">)</span>
</span><span class="line"><span class="nf">notIsEquiv</span> <span class="ow">=</span> <span class="p">[</span> <span class="n">not</span> <span class="p">,</span> <span class="p">[</span> <span class="n">not</span> <span class="p">,</span>  <span class="p">[</span> <span class="n">notnot</span><span class="o">~</span><span class="n">id</span> <span class="p">,</span> <span class="n">notnot</span><span class="o">~</span><span class="n">id</span> <span class="p">]</span>  <span class="p">]</span> <span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="monodromy-for-quasi-equivalences">Monodromy for Quasi-Equivalences</h2>

<p>We now see the subtle problem in using the relation that we called quasi-equivalence. Consider the identity map on a type $A$. Let $g$ be an inverse of the identity, so that both conditions become $g \sim id$. However elements of the type are in general two proofs of $g \sim id$. For $a : A$, these are two paths from $a$ to $g(a)$. Combining these we get a path from $a$ to itself, the <em>monodromy</em>. In type theoretic terms, this is the following.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kt">QImonodromy</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">X</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">)</span> <span class="err">→</span> <span class="n">isQuasiEquiv</span> <span class="p">(</span><span class="n">id</span> <span class="kt">X</span><span class="p">)</span>  <span class="err">→</span> <span class="p">((</span><span class="n">x</span> <span class="kt">:</span> <span class="kt">X</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="p">))</span>
</span><span class="line"><span class="kt">QImonodromy</span> <span class="kt">X</span> <span class="n">qe</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">sym</span> <span class="p">((</span><span class="n">p</span><span class="err">₁</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">qe</span><span class="p">))</span> <span class="n">x</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="err">₂</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">qe</span><span class="p">)</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Thus, for a point $a : A$, an element of $isQuasiEquiv(A)$ gives an element of $a = a$, i.e., a loop. If there are non-trivial loops in $A$, we have more than one proof that identity is an equivalence.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/LogicTypesSpaces/blog/2015/03/30/homotopy-type-theory/">Homotopy Type Theory</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>In <em>homotopy type theory</em> , we interpret a type $A$ as a space $|A|$, and a term $a : A$ as a point $|a| \in |A|$ in the corresponding space. Here space means topological space, but we  do not actually need to know what  this means. All we need of  spaces is:</p>

<ul>
  <li>Subsets of a Euclidean space are spaces.</li>
  <li>For spaces $X$ and $Y$, it is meaningful to talk about continuous functions between them.</li>
  <li>For spaces  $X$ and $Y$, continuous functions between $X$ and $Y$ also form a space $C(X, Y)$.</li>
  <li>Currying and uncurrying are continuous.</li>
</ul>

<h2 id="the-interpretation">The interpretation.</h2>

<p>As mentioned above types and terms are interpreted as spaces and points. For types $A$ and $B$, we interpret $A \to B$ as the space of continuous functions $C(|A|, |B|)$. We can similarly interpret dependent functions, but we shall not go into  details here.</p>

<p>The most crucial ingredient in our interpretation is that of an equality type. For $x, y : A$, the type $x = y$ is interpreted as the space of <em>paths</em> in $|A|$ from $|x|$ to $|y|$, i.e., the space of continuous functions $\alpha: [0, 1] \to |A|$ so that $\alpha(0) = |x|$ and $\alpha(1) = |y|$.</p>

<p>It is a result of Voevodsky and Awodey-Warren that we do have a consistent interpretation of type theory, in the sense we have seen it so far, in which types, terms, (dependent) function types and equality types are mapped in the above fashion.</p>

<p>Given such an interpretation, various topological notions can be defined purely in type theoretic terms. The first of these arises when we ask  when functions are equality.</p>

<h2 id="equality-of-functions">Equality of functions.</h2>

<p>Let $A, B$ be types and $f, g: A \to B$ be functions. Then $f$ and $g$ must be equal if and only if there is  a path between $|f|$ and $|g|$ in $C(|A|, |B|)$. Such a path is a function $[0, 1] \to |A| \to |B|$, which after Uncurrying corresponds to a function $([0, 1] \times |A|) \to |B|$. Flipping the coordinates in the domain and Currying gives a function $|A| \to ([0, 1] \to |B|)$, i.e., a function mapping points of $|A|$ to paths in $|B|$. Indeed, using that the path we started with is from $|f|$ to $|g|$, it is  easy to deduce that a point $|a|$ is mapped to a path from $|f(a)|$ to $|g(a)|$. Such a path corresponds to a term of the type $f(a) = g(a)$!</p>

<p>Thus, we see that  if we have a consistent homotopical interpretation, then the equality type $f = g$ must equal the type
<script type="math/tex">\Pi_{a : A} (f(a) = g(a)).</script></p>

<p>Function extensionality was the postulate that these types  were equal. We shall not postulate this, but instead introduce  and study <em>homotopy</em> type $f\sim g$ corresponding to such equality. We see this  in Agda code. Firstly, we see the definitions for functions and dependent functions.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">_</span><span class="err">∼</span><span class="kr">_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">X</span> <span class="kt">Y</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">g</span> <span class="kt">:</span> <span class="kt">X</span> <span class="err">→</span> <span class="kt">Y</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Type</span>
</span><span class="line"><span class="kr">_</span><span class="err">∼</span><span class="kr">_</span> <span class="p">{</span><span class="kt">X</span><span class="p">}</span> <span class="p">{</span><span class="kr">_</span><span class="p">}</span> <span class="n">f</span> <span class="n">g</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="kt">X</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</span><span class="line">
</span><span class="line"><span class="kr">_</span><span class="o">~</span><span class="kr">_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">X</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="kt">Y</span> <span class="kt">:</span> <span class="kt">X</span> <span class="err">→</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">g</span> <span class="kt">:</span> <span class="p">((</span><span class="n">x</span> <span class="kt">:</span> <span class="kt">X</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="kt">Y</span> <span class="n">x</span><span class="p">)))</span> <span class="err">→</span> <span class="kt">Type</span>
</span><span class="line"><span class="kr">_</span><span class="o">~</span><span class="kr">_</span> <span class="p">{</span><span class="kt">X</span><span class="p">}</span> <span class="p">{</span><span class="kr">_</span><span class="p">}</span> <span class="n">f</span> <span class="n">g</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="kt">X</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>It is easy to see that this gives an equivalence relation.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">rfl</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">X</span> <span class="kt">Y</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="kt">:</span> <span class="kt">X</span> <span class="err">→</span> <span class="kt">Y</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="err">∼</span> <span class="n">f</span><span class="p">)</span>
</span><span class="line"><span class="nf">rfl</span> <span class="p">{</span><span class="kt">X</span><span class="p">}</span> <span class="p">{</span><span class="kr">_</span><span class="p">}</span> <span class="n">f</span> <span class="ow">=</span> <span class="err">λ</span> <span class="n">x</span> <span class="err">→</span> <span class="p">(</span><span class="n">refl</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">))</span>
</span><span class="line">
</span><span class="line"><span class="nf">symm</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">X</span> <span class="kt">Y</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">g</span> <span class="kt">:</span> <span class="kt">X</span> <span class="err">→</span> <span class="kt">Y</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="err">∼</span> <span class="n">g</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">g</span> <span class="err">∼</span> <span class="n">f</span><span class="p">)</span>
</span><span class="line"><span class="nf">symm</span> <span class="p">{</span><span class="kt">X</span><span class="p">}</span> <span class="p">{</span><span class="kr">_</span><span class="p">}</span> <span class="n">f</span> <span class="n">g</span> <span class="n">pf</span> <span class="ow">=</span> <span class="err">λ</span> <span class="n">x</span> <span class="err">→</span> <span class="p">(</span><span class="n">sym</span> <span class="p">(</span><span class="n">pf</span> <span class="n">x</span><span class="p">))</span>
</span><span class="line">
</span><span class="line"><span class="nf">_trans_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">X</span> <span class="kt">Y</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">g</span> <span class="n">h</span> <span class="kt">:</span> <span class="kt">X</span> <span class="err">→</span> <span class="kt">Y</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="err">∼</span> <span class="n">g</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">g</span> <span class="err">∼</span> <span class="n">h</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="err">∼</span> <span class="n">h</span><span class="p">)</span>
</span><span class="line"><span class="nf">_trans_</span> <span class="p">{</span><span class="kt">X</span><span class="p">}</span> <span class="p">{</span><span class="kr">_</span><span class="p">}</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span> <span class="n">f</span><span class="err">∼</span><span class="n">g</span> <span class="n">g</span><span class="err">∼</span><span class="n">h</span> <span class="ow">=</span> <span class="err">λ</span> <span class="n">x</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span><span class="err">∼</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">g</span><span class="err">∼</span><span class="n">h</span> <span class="n">x</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>While these are simple inductive constructions, in topological terms they are more interesting. Given paths $\alpha, \beta: [0, 1] \to X$, for a space $X$, if $\alpha(1) = \beta(0)$ we can define a path $\alpha * \beta$ which is the  path $\alpha$ followed by the path $\beta$. This is the path corresponding to transitivity. Reflexivity corresponds to constant paths. Finally symmetry corresponds to the map associating to a path $\alpha$ the path $\bar{\alpha}: t \mapsto \alpha(1-t)$.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/LogicTypesSpaces/blog/2015/02/09/exercises-for-midterm/">Exercises for Midterm</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>These exercises are for review before the midterm. They are not to be submitted.</p>

<ol>
  <li>
    <p>Let $\_\le\_$ denote the type family corresponding to the <em>less than or equal to</em> relation. For a function $f : \mathbb{N} \to \mathbb{N}$, what does the type $\Pi_{n : \mathbb{N}}\Pi_{m : \mathbb{N}} (m \le n \to f(n) \le f(m))$ represent?</p>
  </li>
  <li>
    <p>For fixed types $A$ and $B$, recall that $A \times B$ is an inductive type. For a type $W$, what is the type of $rec_{A \times B, X}$? Relate this to Currying functions.</p>
  </li>
  <li>
    <p>For a function $f : \mathbb{N} \to \mathbb{N}$, define a type corresponding to $f$ being bounded (above), using the type family $\_\le\_$.</p>
  </li>
  <li>
    <p>Let $S$ be a type. Define an inductive type $W(S)$ whose terms are words, i.e., finite sequences, with each letter an element of $S$ or the formal inverse of an element of $S$. For example, if $S$ is the set (which we view as a type) $S = \{a, b\}$, then a term of $W(S)$ is $ab\bar{a}a\bar{b}$.</p>
  </li>
</ol>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/LogicTypesSpaces/blog/2015/02/02/logic-from-types/">Logic From Types</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>At the core of homotopy type theory (and its predecessors) is the idea of <em>propostions as types</em>. Namely, we interpret logical <em>propositions</em> - statements that are either true or false, as <em>types</em>, with a <em>term</em> having a given type being viewed as a <em>proof</em> of the corresponding proposition. The Curry-Howard correspondence lets us embed all of logic into type theory in the manner.</p>

<h3 id="true-and-false">True and False</h3>

<p>We begin by representing the two simplest propositions: true - always true,  and false.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>True and False types</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">True</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">qed</span> <span class="kt">:</span> <span class="kt">True</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="kr">data</span> <span class="kt">False</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The $True$ type has just one constructor, giving an object with type $True$. On the other hand, the $False$ type has no constructors, so there are no objects of type $False$.</p>

<p>There are various ways of building propositions from other propositions. We see how these translate to constructions of types.</p>

<h3 id="logical-implies">Logical implies</h3>

<p>If $P$ and $Q$ are propositions, which we identify with their corresponding types. We interpret the proposition $P \implies Q$ as the function type $P \to Q$.</p>

<h3 id="some-deductions">Some deductions</h3>

<p><em>Modus Ponens</em> is the rule of deduction (going back to antiquity) that says that if the proposition $P$ is true, and $P$ implies $Q$, then $Q$ is true. We can prove this in the types interpretation. Namely, Modus Ponens translates to the statement that if we have an objects of type $P$ and $P \to Q$, then we have an object of type $Q$. We get an object of type $Q$ by function application.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">mp</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">P</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="kt">Q</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">P</span> <span class="err">→</span> <span class="p">(</span><span class="kt">P</span> <span class="err">→</span> <span class="kt">Q</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Q</span>
</span><span class="line"><span class="nf">mp</span> <span class="n">p</span> <span class="n">imp</span> <span class="ow">=</span> <span class="n">imp</span> <span class="n">p</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Next, we see my favourite method of proof - vacuous implication. This says that a false statement implies everything, i.e., for any proposition $P$, we have $False \implies P$, which in type theory says $False\to P$ has objects.</p>

<p>As the $False$ type has no cases at all, a function is defined on $False$ by using an absurd pattern, which just says that there are no cases, so no definition is needed.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">vacuous</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">False</span> <span class="err">→</span> <span class="kt">A</span>
</span><span class="line"><span class="nf">vacuous</span> <span class="nb">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Formally, as the $False$ type has no constructors, the recursion function $rec_{False, A}$ has type $False \to A$. We simply take this as the vacuous implication.</p>

<h3 id="even-and-odd-numbers">Even and Odd numbers</h3>

<p>Next, we define a type family $Even(n)$, for $n : \mathbb{N}$, which is non-empty if and only if $n$ is even. To do this, we see that a number is even if and only if it is even as a consequence of the rules</p>

<ul>
  <li>$0$ is even.</li>
  <li>If $n$ is even, so is $n + 2$.</li>
</ul>

<p>Thus, we can define the inductive type family:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Even</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="mi">0</span><span class="n">even</span> <span class="kt">:</span> <span class="kt">Even</span> <span class="mi">0</span>
</span><span class="line">  <span class="kr">_</span><span class="o">+</span><span class="mi">2</span><span class="n">even</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Even</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Even</span> <span class="p">(</span><span class="n">succ</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can prove that $4$ is even by applying the second constructor to the first constructor (telling us that $0$ is even) twice.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="mi">4</span><span class="n">even</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">0</span><span class="n">even</span> <span class="o">+</span><span class="mi">2</span><span class="n">even</span><span class="p">)</span> <span class="o">+</span><span class="mi">2</span><span class="n">even</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We next show that $1$ is odd. This means that we have to show that the type $Even\ 1$ is empty. While rules let us construct objects, and verify their types, there is no rule that tells us directly that a type is empty.</p>

<p>However, there is a nice way of capturing that a type $A$ is empty - if there is a function from $A$ to the empty type $False$, then $A$ must be empty - there is nowhere for an object of type $A$ to be mapped.</p>

<p>Indeed, what we prove is that there is a function from $Even\ 1$ to $False$ ; we define this using an absurd pattern.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>1 is odd</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="mi">1</span><span class="n">odd</span> <span class="kt">:</span> <span class="kt">Even</span> <span class="mi">1</span> <span class="err">→</span> <span class="kt">False</span>
</span><span class="line"><span class="mi">1</span><span class="n">odd</span> <span class="nb">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This can be formalized by defining a dependent function on the inductive type family $Even$ with appropriate type.</p>

<h3 id="more-types-for-propositions">More types for propositions</h3>

<p>We now see the types corresponding to other ways of combining propositions: logical operations <em>and</em> and <em>or</em>.</p>

<p>Firstly, if $A$ and $B$ are types corresponding to propositions, then there are objects with each of these types if and only if there is a pair $(a, b)$ of the pair type $A \times B$.</p>

<p>Next, suppose $A$ and $B$ are types corresponding to propositions and we wish to construct a type corresponding to $A$ <em>or</em> $B$, then we require a type whose elements are elements of $A$ and elements of $B$, or more accurately the images of such elements under constructors. This is the direct sum type.</p>

<p>The above methods let us combine propositions without quantifiers in all the logical ways. In doing so we used type theory, but not dependent types. Dependent types also let us express logical statements with quantifiers.</p>

<h3 id="for-all">For all</h3>

<p>Suppose we have a type $A$ and a family of types $P(a)$ (which we regard as propositions), with a type associated to each object $a$ of type $A$. Then all the types $P(a)$ have objects  (i.e., all corresponding propositions are true) if and only if there is a dependent function mapping each object $a$ of type $A$ to an object of type  $P(a)$. Thus, the logical statement</p>

<script type="math/tex; mode=display">\forall a \in A\ P(a)</script>

<p>translates to the product type</p>

<script type="math/tex; mode=display">\prod\limits_{a : A} P(a).</script>

<p>As we have seen, in Agda we represent the product type as $(a : A) \to P(a)$</p>

<h3 id="exists">Exists</h3>

<p>Next, if we are given a collection of types $B(a)$ for objects $a$ of type $A$, the type corresponding to at least one of these types having an element is a $\Sigma$-type, as there is an element of $B(a)$ for at least one $a : A$ if and only if there is a pair term $(a, b)$ with $b : B(a)$.</p>

<h2 id="a-proof-by-induction">A proof by induction</h2>

<p>If $n$ is a natural number, we can prove by induction that one of $n$ and $n+1$ is even. We shall prove this in its  type theoretic form. We will do this in an Agda module to keep notation clean - the module consists of all the tab spaced lines following its definition. In the following code, we define the property that for all $n$, one of $n$ and $n+1$ is even as $P$ (in a submodule). We then prove the induction step and use  it to prove  the  theorem.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">module</span> <span class="err">n|n+1even</span> <span class="err">where</span>
</span><span class="line">  <span class="nn">P</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Type</span>
</span><span class="line">  <span class="kt">P</span> <span class="n">n</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Even</span> <span class="n">n</span><span class="p">)</span> <span class="err">⊕</span> <span class="p">(</span><span class="kt">Even</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">))</span>
</span><span class="line">
</span><span class="line">  <span class="n">step</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">P</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line">  <span class="n">step</span> <span class="p">(</span><span class="err">ι₁</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="err">ι₂</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span><span class="mi">2</span><span class="n">even</span><span class="p">)</span>
</span><span class="line">  <span class="n">step</span> <span class="p">(</span><span class="err">ι₂</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="err">ι₁</span> <span class="n">p</span>
</span><span class="line">
</span><span class="line">  <span class="n">thm</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span>
</span><span class="line">  <span class="n">thm</span> <span class="mi">0</span> <span class="ow">=</span> <span class="err">ι₁</span> <span class="mi">0</span><span class="n">even</span>
</span><span class="line">  <span class="n">thm</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">step</span> <span class="p">(</span><span class="n">thm</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The definition is just a translation of the logical or into dependent sums and of $\forall$ into dependent functions.</p>

<p>In the induction step, we assume that we have a proof for $n$. Thus $n$ and the corresponding proof are arguments, but $n$ can be inferred. There are two cases - if we have a proof that $n$ is even (i.e., the first alternative  for $P(n)$), we obtain a proof that $n+2 = (n+1) + 1$ is even by using the  rule $\_+2even$, which is the second alternative for the statement $P(n+1)$. In the case where  $n + 1$ is  even, we directly obtain the first  alternative for $P(n+1)$.</p>

<p>The theorem itself is simply obtained by putting together the base case and the induction step.</p>

<p>This proof is remarkable in many ways. First of all, note that this is no longer or more complicated than an informal proof. Further, note that we did not have to invoke the usual induction axiom schema, but instead just used the rules for constructing objects. Most significantly, as most of our types are inductive type (or type families), we get recursive definitions and inductive proofs in all these cases.</p>

<p>Indeed,  using recursive definitions for inductive types we get all so called <em>universal properties</em>. Furthermore, traditionally universal properties require a separate uniqueness statement. But recursion-induction is powerful enough to even give the uniqueness statements for universal properties. This means a great deal of mathematical sophistication (universal algebra, various aspects of category theory) are encapsulated in these simple functions.</p>

<h2 id="functions-with-conditions-and-certificates">Functions with conditions and certificates.</h2>

<p>Often functions are meant to be defined only when some conditions are satisfied, for instance we may  wish to define a function $half : \mathbb{N} \to \mathbb{N}$ only for even integers. Traditionally, the way to deal with this situation is either to check the conditions, and declare an error (“throw an exception”) if they fail, or return some (incorrect) value if the condition fails perhaps causing serious errors elsewhere.</p>

<p>With propositions as types, there is a better alternative - the function can require, as an additional argument, a <em>proof</em> that a condition is satisfied. For instance, here is such a function.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">half</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Even</span> <span class="n">n</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">half</span> <span class="o">.</span><span class="mi">0</span> <span class="mi">0</span><span class="n">even</span> <span class="ow">=</span> <span class="mi">0</span>
</span><span class="line"><span class="nf">half</span> <span class="p">(</span><span class="n">succ</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">))</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span><span class="mi">2</span><span class="n">even</span><span class="p">)</span> <span class="ow">=</span> <span class="n">succ</span> <span class="p">(</span><span class="n">half</span> <span class="n">n</span> <span class="n">p</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Our definition also illustrates Agda’s <em>dot</em> notation. The first argument in the first case being <strong>.0</strong> means that we can infer from types that its value must be zero.</p>

<p>Note that in the second case we must have a pattern of the form $succ(succ (n))$, from which it can be deduced that $p$ has type $Even n$. If we just tried to match to $n$, then we cannot in general reconcile the terms and types.</p>

<p>We may also wish to assert that the result of functions have some additional property - for instance that a function returns a <em>sorted</em> list. This is best achieved if the value of the function includes a proof that the condition holds. For example, the following function doubles a number and also gives evidence that it is even.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">double</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="err">Σ</span> <span class="err">ℕ</span> <span class="kt">Even</span>
</span><span class="line"><span class="nf">double</span> <span class="mi">0</span> <span class="ow">=</span> <span class="p">[</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">0</span><span class="n">even</span> <span class="p">]</span>
</span><span class="line"><span class="nf">double</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">succ</span> <span class="p">(</span><span class="n">succ</span> <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="p">(</span><span class="n">double</span> <span class="n">n</span><span class="p">))))</span> <span class="p">,</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="p">(</span><span class="n">double</span> <span class="n">n</span><span class="p">))</span> <span class="o">+</span><span class="mi">2</span><span class="n">even</span> <span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can use the proof provided by such a function to apply a function that requires a proof.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">halfdouble</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">halfdouble</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">half</span> <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="p">(</span><span class="n">double</span> <span class="n">n</span><span class="p">))</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="p">(</span><span class="n">double</span> <span class="n">n</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="the-collatz-function">The Collatz function.</h3>

<p>As a more complex example, we construct the  function governing the <a href="http://en.wikipedia.org/wiki/Collatz_conjecture">Collatz conjecture</a>, which maps a natural number  $n$ to $n/2$ if $n$ is even, and $3n + 1$ if $n$ is odd, or equivalently $n+1$ is even. We use our halving function  with proof, and the proof that one of $n$ and $n+1$ is even.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">module</span> <span class="nn">Collatz</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">frompf</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="n">n</span><span class="o">|</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="n">even</span><span class="o">.</span><span class="kt">P</span> <span class="n">n</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line">  <span class="n">frompf</span> <span class="n">n</span> <span class="p">(</span><span class="err">ι₁</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">half</span> <span class="n">n</span> <span class="n">p</span>
</span><span class="line">  <span class="n">frompf</span> <span class="n">n</span> <span class="p">(</span><span class="err">ι₂</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line">  <span class="n">fn</span> <span class="ow">=</span> <span class="err">λ</span> <span class="n">n</span> <span class="err">→</span> <span class="n">frompf</span> <span class="n">n</span> <span class="p">(</span><span class="n">n</span><span class="o">|</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="n">even</span><span class="o">.</span><span class="n">thm</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Note that we access a term <em>T</em> in the module <em>n|n+1even</em> from outside the module by prefacing it with <em>n|n+1even.</em> to get <em>n|n+1even.T</em>.</p>

<h3 id="the-identity-type">The identity type</h3>

<p>One of the most fundamental concepts in homotopy type theory is the identity type family, representing equality between objects with a given type. This is an inductive type family, generated by the reflexivity constructor giving an equality between an object and itself.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>The identity type</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kr">_</span><span class="o">==</span><span class="kr">_</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">refl</span> <span class="kt">:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="n">a</span> <span class="o">==</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Note that while this is an inductive type family, for a fixed object a the type $a==a$ is <em>not</em> an inductive type defined by $refl(a)$, i.e., we cannot define (dependent) functions on this type but just defining them on the reflexivity constructor. This is a subtle point, which will become clearer as we look at the topological interpretation. We shall study the identity type extensively.</p>

<p>For now, let us show some basic properties of the identity type. All these are proved by constructing proof terms by induction. These are in a separate module <strong>Id</strong>.</p>

<p>Firstly, we see that equality (given by the identity type) is symmetric and transitive. Symmetry is straightforward.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">sym</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">x</span> <span class="n">y</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">}</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="err">→</span> <span class="n">y</span> <span class="o">==</span> <span class="n">x</span>
</span><span class="line"><span class="nf">sym</span> <span class="p">(</span><span class="n">refl</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">refl</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Next, we see transitivity of equality, for which we use $\&amp;\&amp;$ as notation.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">_</span><span class="o">&amp;&amp;</span><span class="kr">_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">}</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="err">→</span> <span class="n">y</span> <span class="o">==</span> <span class="n">z</span>  <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">z</span>
</span><span class="line"><span class="kr">_</span><span class="o">&amp;&amp;</span><span class="kr">_</span> <span class="p">(</span><span class="n">refl</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">refl</span> <span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">refl</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We have once more used the <em>dot notation</em>. Notice that we have a term <strong>.a</strong> - this says that we can deduce, <em>from the types</em>, that $a$ is the only possibility at its position in the pattern.</p>

<p>If two terms are equal, then the terms resulting from applying a function to them are also equal. We prove this next.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">_</span><span class="o">#</span><span class="kr">_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">x</span> <span class="n">y</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span><span class="p">)</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">f</span> <span class="n">y</span><span class="p">)</span>
</span><span class="line"><span class="nf">f</span> <span class="o">#</span> <span class="p">(</span><span class="n">refl</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">refl</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>As we see, we can express all the usual mathematical statements using types built up using our basic constructions: inductive types, functions and dependent functions. We have also seen that the basic rules for constructing objects are powerful rules of deduction. However, there are some things they cannot deduce, for instance the statement (called the axiom of extensionality) that if $f, g: A\to B$ are function with $f(a)=g(a)$ for all $a \in A$, then $f=g$. Hence, we have to introduce this as a postulate - we just postulate that  there is an object (which we give a name) of a given type.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">postulate</span>
</span><span class="line">  <span class="n">extensionality</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">g</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span><span class="p">)</span> <span class="err">→</span> <span class="p">((</span><span class="n">x</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span> <span class="err">→</span> <span class="n">f</span> <span class="o">==</span> <span class="n">g</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can similarly introduce axioms specific to a domain, say Euclidean geometry, by postulating them in a module.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/LogicTypesSpaces/blog/2015/01/30/fin-type-family/">Fin Type Family</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>We briefly saw the <strong>Fin</strong> type family when constructing trees. We clarify and elaborate on its construction.</p>

<p>The <strong>Fin</strong> type family is indexed by natural numbers $\mathbb{N}$. For $n : \mathbb{N}$, $Fin(n)$ is a finite type with $n$ elements, corresponding to the integers $k$ with $0 \leq k &lt; n$. We denote by $[k]_n$ the element corresponding to the natural number $k$ in $Fin(n)$. Note that $[1]_2$ and $[1]_3$ are <strong>not</strong> the same term even though they correspond to the same natural number.</p>

<p>We define $Fin$ as an inductive type family with two constructors. In Agda, this is as follows.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Fin</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">fzero</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line">  <span class="n">fsucc</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The constructors are similar to the $zero$ and $succ$ constructors for natural numbers. However, as remarked earlier,  $[0]_2$ and $[0]_3$ are <strong>not</strong> the same term, so the constructor $fzero$ takes an argument specifying the type of the term constructed. Since $Fin(0)$ does not have a term corresponding to $0$, but $Fin(k)$ does for $k \geq 1$, we set $fzero(n) = [0]_{n +1}$. Formally, as usual, we only specify the type of $fzero$ and declare it to be a constructor.</p>

<p>The second constructor $fsucc$ takes $[k]_n$ to $[ k + 1]_{n +1}$. On the associated natural numbers, this is just the successor function. However it maps the type $Fin(n)$ to the type $Fin(n+1)$ - as one should expect since, given $0 \leq k &lt; n$, we need not have $k + 1 &lt;n$, but always have $0 \leq k+1 \leq n +1$.</p>

<p>Note that if $0\leq k &lt;n$, then there is unique way to obtain $[k]_n$ using the given constructors, namely (using powers to denote iterated application) $[k]_n = fsucc^k (fzero (n -k -1))$.</p>

<p>By a recursive definition, we can define the function $[k]_n \mapsto k$.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_as</span><span class="err">ℕ</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="n">n</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">fzero</span> <span class="n">as</span><span class="err">ℕ</span> <span class="ow">=</span> <span class="mi">0</span>
</span><span class="line"><span class="p">(</span><span class="n">fsucc</span> <span class="n">k</span><span class="p">)</span> <span class="n">as</span><span class="err">ℕ</span> <span class="ow">=</span> <span class="n">succ</span> <span class="p">(</span><span class="n">k</span> <span class="n">as</span><span class="err">ℕ</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/LogicTypesSpaces/blog/2015/01/25/rooted-trees-and-general-induction/">Rooted Trees and General Induction</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>We now consider a more complex example, which illustrates the most general form of constructors for inductive types.</p>

<p>A rooted tree with leaf labels of type $A$ is a structure built recursively, being of one of the forms:</p>

<ul>
  <li>a single vertex, which is the root, with a label from $A$, or</li>
  <li>a vertex, the root, to which are attached finitely many rooted trees with leaf labels by an edge to their roots.</li>
</ul>

<p>To model this, specifically to model “finitely many rooted trees”, we introduce the inductive type family associating to a natural number $n: \mathbb{N}$ the set of natural numbers less than $n$.</p>

<h2 id="the-fin-type-family">The Fin type family.</h2>

<p>We construct an inductive type family $Fin: \mathbb{N} \to \mathcal{U}$, with $Fin(n)$ consisting of integers $k$ with $0 \leq k &lt; n$. For $n &gt;0$, this has an element $0$. Further, if $k$ gives an element of $Fin(n)$, then $k + 1$ is an element of $Fin(n +1)$. It is easy to see that these give the constructors of the type family. Thus,</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Fin</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">fzero</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line">  <span class="n">fsucc</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Fin</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="inductive-family-for-rooted-trees">Inductive family for rooted trees.</h2>

<p>Observe that for $n : \mathbb{N}$, a collection of $n$ objects of type $X$ can be viewed as a function $Fin(n) \to X$. To consider all finite trees we consider terms of type $\Pi_{n : \mathbb{N}} Fin(n)\to X$. Using this, we can define the inductive type of rooted trees with leaf labels of type $A$.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">RootedTree</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">leaf</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">RootedTree</span> <span class="kt">A</span>
</span><span class="line">  <span class="n">node</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="kt">Fin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">RootedTree</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="kt">RootedTree</span> <span class="kt">A</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="constructors-recursion-and-induction-generalized">Constructors, Recursion and Induction generalized</h2>

<p>Note that the constructor for rooted trees is not of the earlier forms, but a more general form. For a type $W$, we can regard a term of $A \to W$ as giving a family of terms of $W$, indexed by $A$. More generally, we can construct families by regarding $W$ itself as the type of a family, and regarding functions, and dependent functions, to families of terms of $W$ as families of terms of $W$. Note that the domains cannot involve $W$.</p>

<p>We add another rule for types of constructors for $W$. This completes our list of constructors, so we now have the full definition of inductive types.</p>

<ul>
  <li>If $T$ is the type of a constructor of $W$, and $V = \dots \to W$ is the type of a family of terms of $W$, then $V \to W$ can be the type of a constructor.</li>
</ul>

<p>Consider recursive and inductive definitions on rooted trees, or more generally inductive types with constructors including the new type. The value of a function on a node can depend on values on each of the rooted trees that constitute it. To formalize this, observe that if $\alpha: A \to W$ is a family of terms of type $W$, and $f : W\to X$, then we obtain a function $f \circ \alpha: A \to X$ by composition. The value of $f$ on the image of the constructor can depend on $F \circ \varphi$.</p>

<p>We thus make the following rule for $R_{W, X}$, which is easy to generalize to arbitrary families and to induction functions.</p>

<ul>
  <li>If $T$ is the type of a constructor of of $W$, $A$ is a type and $\alpha : A \to W$ is a variable (or term), then for a constructor $\varphi : (A \to W) \to T$, we have $R_{W, X}(\varphi) = (A \to W) \to (A \to X) \to R_{W, X}(\varphi(\alpha))$.</li>
</ul>

<h2 id="exercise">Exercise:</h2>

<ul>
  <li>
    <p>Define a fold function, which, given $n : \mathbb{N}$ (which can be inferred), $f: Fin(n) \to A$ and $\_ *\_ : A \times B \to B$, for types $A$ and $B$, has result
$f(0) * (f(1) * (\dots * (f(n-1) * b)))$</p>
  </li>
  <li>
    <p>Define a function that, given a rooted tree with leaf labels in $A$ gives the list of labels.</p>
  </li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/LogicTypesSpaces/blog/2015/01/23/constructing-dependent-functions/">Constructing Dependent Functions</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>While we have introduced dependent functions, we do not formally have any way to construct them - those constructed so far used pattern matching. We shall generalize the two ways we have seen to construct functions, <em>lambdas</em> and using <em>recursion functions</em> to constructions of dependent functions. In doing so we also review and clarify the case of ordinary functions.</p>

<h2 id="lambdas">Lambdas</h2>

<p>We can construct a function of type $A \to B$ as a lambda, i.e., we consider an $\lambda$-expression $\lambda a \to b$, which is usually denoted $a \mapsto b$ in mathematics. More precisely,</p>

<ul>
  <li>$a$ is a variable of type $A$. This is just a term with a name, which we temporarily introduce. Note that the type $A$ may not have any terms at all.</li>
  <li>$b$ is an expression (judgmentally) of type $B$ which can involve $a$. This means that $b$ is a term formed by the usual rules for forming terms - applying a function to an argument, constructing function types, lambdas etc., except that we can use the term $a : A$ along with other terms previously introduced to the context.</li>
  <li>When we apply $\lambda a \to b$ to $a’ : A$, we obtain the result of <em>substituting</em> $a’$ for $a$ in $b$. For this to be meaningful, it is to be understood that our rules for forming terms include rules for <em>substitution</em>.</li>
</ul>

<p>It is clear how to generalize this to obtain dependent functions, with type say $\Pi_{a : A} B(a)$. Namely, we consider terms $\lambda a \to b$ so that the expression $b$ has type $B(a)$.</p>

<h2 id="recursion-functions-revisited">Recursion functions revisited.</h2>

<p>Functions on inductive types can be constructed using associated recursion functions. We clarify this in the case of the simple inductive types we have considered so far, and extend this to some more general inductive types.</p>

<h4 id="constructors-for-w">Constructors for $W$</h4>

<p>For a type $W$, previously, we considered constructors as terms with type that can be obtained in the following ways.</p>

<ul>
  <li>$W$ itself can be the type of a constructor.</li>
  <li>If $T$ is the type of a constructor, then $W \to T$ can also be a type of a constructor for $W$.</li>
  <li>If $T$ is the type of a constructor and $A$ is a type not involving $W$, then $A \to T$ can also be a type of a constructor for $W$.</li>
</ul>

<p>It may seem that any type $X$ should fall into one of the latter two cases, but this is not so. For example $W \to W$ is not in either case, and indeed $(W \to W) \to W$ is not a valid type for a constructor.</p>

<p>Observe that for a constructor $g$ of the type $W \to T$, if $b : B$ then $g(b)$ is also a constructor, and we have a similar statement for the type being $A \to W$.</p>

<p>We now look at two more ways of obtaining constructors, with functions in the second and third rule above generalized to dependent functions.</p>

<ul>
  <li>If we have a function associating to $w : W$ the type $T(w)$ of a constructor for $W$, then $\Pi_{w : W} T(w)$ can also be the type of a constructor.</li>
  <li>If $A$ is a type not involving $W$ and we have a function associating to $a : A$ the type $T(a)$ of a constructor for $W$, then $\Pi_{a : A} T(a)$ can also be the type of a constructor.</li>
</ul>

<h4 id="domains-of-recursion">Domains of Recursion</h4>

<p>Given a constructor $\varphi$ for $W$ and a type $X$, we obtain a type which we call the <em>domain of recursion</em> of $\varphi$ and denote $R_{W, X}(\varphi)$. For constructors obtained using the above rules, we define this as follows. Note that we could have defined this purely in terms of the type of $\varphi$, but we chose the definition to be parallel to the case for dependent functions.</p>

<ul>
  <li>If $\varphi : W$, then $R_{W, X}(\varphi) = W$.</li>
  <li>If $\varphi : W \to T$ and $w : W$ is a variable (or term), then $R_{W, X}(\varphi) = W \to X \to R_{W, X}(\varphi(w))$. Note that this does not depend on the choice of $w : W$. Indeed it is determined by the type $T$ of $\varphi(w)$.</li>
  <li>If $\varphi : A \to T$ and $a : W$ is a variable (or term), then $R_{W, X}(\varphi) = A \to R_{W, X}(\varphi(w))$. Note that this does not depend on the choice of $a : A$. Indeed it is determined by the type $T$ of $\varphi(a)$.</li>
  <li>If $\varphi : \Pi_{w: W} T(w)$, then $R_{W, X}(\varphi) = \Pi_{w: W} (W \to X \to R_{W, X}(\varphi(w))).$</li>
  <li>If $\varphi : \Pi_{a: A} T(a)$ with the type $A$ not involving $W$, then $R_{W, X}(\varphi) = \Pi_{a: A} (A \to R_{W, X}(\varphi(w))).$</li>
</ul>

<p>If we have a type such as $W \to W$ that involves $W$ but is not equal to $W$, it is not clear whether the second or third ruls applies. We shall eventually allow some such types, but not others. For these we will extend the rules for $W$.</p>

<h4 id="the-recursion-function">The recursion function</h4>

<p>Suppose now that $W$ is given by constructors $\varphi_1$, $\dots$, $\varphi_k$. Then when defining $W$, we introduce for each type $X$ a term $rec_{W, X}$ with type</p>

<script type="math/tex; mode=display">rec_{W, X} : R_{W, X}(\varphi_1) \to \dots \to R_{W, X}(\varphi_k) \to (W \to X)</script>

<p>We make certain judgments, giving definitional equalities involving the recursion function.</p>

<h2 id="induction-functions">Induction functions</h2>

<p>It is straightforward to modify the above for definitions of dependent functions. The analogues of recursive definitions for dependent functions are called <em>inductive definitions</em>, and these are interpreted in terms of <em>induction functions</em>.</p>

<h4 id="for-natural-numbers">For natural numbers</h4>

<p>First we briefly consider an example, namely dependent functions on $\mathbb{N}$. Suppose $X : \mathbb{N} \to \mathcal{U}$ is a type family. To define inductively a dependent function $f : \Pi_{n : \mathbb{N}} X(n)$, we must specify</p>

<ul>
  <li>$f(0)$, of type $X(0)$.</li>
  <li>For all $n$, $f(n + 1) : X(n+1)$ in terms of $n : \mathbb{N}$ and $f(n) : X(n)$.</li>
</ul>

<p>Thus we require a term of type $X(0)$, and for each $n$, a term of type $X(n+1)$ as a function of a term of type $\mathbb{N}$ and a term of type $X(n)$. The latter data can be viewed as a single term of type $\Pi_{n : \mathbb{N}} (X(n) \to X(n+1))$. Thus, the induction function for natural numbers has the type</p>

<script type="math/tex; mode=display">ind_{W, X} :  X(0) \to \Pi_{n : \mathbb{N}} (X(n) \to X(n+1)) \to \Pi_{n : \mathbb{N}} X(n).</script>

<p>Notice that this type involves the expression $n+1 = succ(n)$, so the type depends on the constructor $\varphi$, not just its type.</p>

<h4 id="domains-of-induction">Domains of induction</h4>

<p>Given now a type family $X$, we define for constructors $\varphi$ constructed as above a type $I_{W, X}(\varphi)$ as follows.</p>

<ul>
  <li>If $\varphi : W$, then $I_{W, X}(\varphi) = W$.</li>
  <li>If $\varphi: W \to T$, then $I_{W, X}(\varphi) = \Pi_{w: W} (X(w) \to I_{W, X}(\varphi(w)))$.</li>
  <li>If $\varphi: A \to T$, then $I_{W, X}(\varphi) = \Pi_{a: A} I_{W, X}(\varphi(a))$.</li>
  <li>If $\varphi: \Pi_{w: W} T(w)$, then $I_{W, X}(\varphi) = \Pi_{w: W} (X(w) \to I_{W, X}(\varphi(w)))$.</li>
  <li>If $\varphi: \Pi_{a : A} T(a)$, then $I_{W, X}(\varphi) = \Pi_{a: A} I_{W, X}(\varphi(a))$.</li>
</ul>

<p>Observe that the constructors involving dependent functions are essentially the same as those involving ordinary functions.</p>

<h4 id="the-induction-function">The induction function</h4>

<p>This can now be introduced in a manner similar to the recursion function. Suppose now that $W$ is given by constructors $\varphi_1$, $\dots$, $\varphi_k$. Then when defining $W$, we introduce for each type family $X$ a term $ind_{W, X}$ with type</p>

<script type="math/tex; mode=display">rec_{W, X} : I_{W, X}(\varphi_1) \to \dots \to I_{W, X}(\varphi_k) \to (\Pi_{w: W} X(w)).</script>

<p>We make certain judgments, giving definitional equalities involving the induction function.</p>

<h2 id="inductive-type-families">Inductive type families</h2>

<p>We now sketch the generalization to <em>inductive type families</em>.</p>

<h4 id="type-families">Type families</h4>

<p>A type family is one of:
* A type $W : \mathcal{U}$.
* A function from a type $A$ to type families.</p>

<p>Thus, a typical type family is $A \to B \to \mathcal{U}$ or $\Pi_{a : A} (B(a)\to mathcal{U})$.</p>

<h4 id="inductive-type-families-1">Inductive type families</h4>

<p>An inductive type family, say $W : A \to \mathcal{U}$, is a type family which is determined by constructors and for which there are recursion and induction functions. The most important point to note about such a family is that even though, for $a: A$, $W(a)$ is a type, it is <strong>not</strong> an inductive type. For instance, for a type $X$ we do not have a recursion function $rec_{W(a), X}$. Instead we can recursively (and inductively) define (dependent) functions for all values of the index, i.e., we have a recursion function with type of the form</p>

<script type="math/tex; mode=display">rec_{W, X} : \dots \to \Pi_{a : A}(W(a) \to X)</script>

<p>and similarly for inductive functions.</p>

<h4 id="constructors-for-families">Constructors for families.</h4>

<p>Consider an inductive type family $W : A \to \mathcal{U}$. It is meaningless to talk of a constructor of type $W$, as $W$ is not a type. Instead basic constructors for such families are of the form $W(a)$ for $a : A$. Similarly, we can extend a constructor $T$ to $W(a’) \to T$.</p>

<p>Definitions of recursion and induction functions for type families from constructors are easy generalizations of the definitions for inductive types.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/LogicTypesSpaces/blog/2015/01/22/dependent-function-types/">Dependent Function Types: Sections of a Bundle</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="dependent-functions">Dependent functions</h2>

<p>A function $f$ on a domain $A$ when applied to an elements $a$ of type $A$ gives a value $f(a)$. Further, a function is determined by the values it gives, in the sense that if $f$, $g$ are functions with domain $A$ so that</p>

<script type="math/tex; mode=display">\forall x\in A, f(x) = g(x)</script>

<p>then
<script type="math/tex">f=g.</script></p>

<p>Dependent functions generalize functions, with the above properties continuing to hold. What we no longer require is that $f(a)$ has a fixed type independent of $a$, namely the codomain B. Instead we have a family of codomains $B(a)$, so that $f(a)$ has type $B(a)$.</p>

<p>Such objects are common in mathematics (and physics). For example, the velocity of water flowing on a sphere  gives a vector field on a sphere. At a point $x$ on the sphere, the value of the vetor field $V$ lies in the tangent space at the point, i.e.,</p>

<script type="math/tex; mode=display">V(x) \in T_x S^2.</script>

<p>Hence it is best to view vector fields as dependent functions. In mathematics, the codomains are generally called fibers, which together form a fiber bundle, and dependent functions are called sections of this bundle.</p>

<p>We can (and often do) regard a dependent function as an ordinary function with codomain the union of the various codomains. But, besides losing information, the function we get is not natural, in the sense that it does not respect the underlying symmetries.</p>

<h2 id="products-and-pi-types">Products and $\Pi$-types</h2>

<p>Another situation which is best viewed in terms of dependent functions is a product. Consider a product $A_1 \times A_2 \times \dots \times A_n$. An element of such a product is a tuple $(a_a, a_2, dots, a_n)$. We would like to view such tuples as functions $a$ on the index set $\{1, 2, \dots, n\}$, but to do so we would have to require $a(i) : A_i$, i.e., a separate codomain for each index. Thus tuples are dependent functions.</p>

<p>More generally, if we have a family of types $B(a)$ indexed by a set $A$, then elements of the product</p>

<script type="math/tex; mode=display">\Pi_{a : A} B(a)</script>

<p>are exactly dependent functions $f$ on $A$ so that $f(a)$ has type $B(a)$ for $a : A$. Thus a type of dependent functions is denoted as in $\Pi_{a : A} B(a)$ and is often called a $\Pi$-type.</p>

<h2 id="examples-and-code">Examples and code</h2>

<p>We now turn to some simple examples and code. First we consider type families, which give the collection of codomains for dependent functions. The typical example is vectors of length $n$ of elements of a type $A$. Formally, a type family is just a function with codomain a universe, so the values the function takes are types.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>The Type family of vectors of length n</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Vec</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="kt">[]</span>   <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">zero</span>
</span><span class="line">  <span class="kr">_</span><span class="ow">::</span><span class="kr">_</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This gives a family of types <em>parametrized</em> by A and <em>indexed</em> by natural numbers. The difference between parameters and indices is a bit subtle but crucial. Observe that the Agda syntax treats them quite differently.</p>

<h3 id="inductive-types-and-inductive-type-families">Inductive types and inductive type families</h3>

<p>We defined Booleans and natural numbers using the data statement, and defined functions on them by pattern matching. More conceptually, these are inductive types, and functions defined on them are defined by applying the recursion function. For instance, in the case of Booleans, the recursion function takes as input a type $A$ and two objects with that type (the values of $true$ and $false$) and gives a function from Booleans to $A$.</p>

<p>In the case of lists, for each type $A$, we obtain a corresponding inductive type. Thus we have a family of inductive types, parametrized by the type $A$.</p>

<p>In the case of vectors too, the type $A$ acts as a parameter.  Assume that the type $A$ is fixed, so vectors are now a family of types indexed by natural numbers.</p>

<p>However, the vectors of a fixed size (say $7$) do not form an inductive type - we cannot define a function recursively on vectors of length $7$ alone.  In this case, this is evident from the definition, as the constructor giving vectors of size $7$ uses vectors of size $6$. So a recursive definition must also involve vectors of size $6$, hence of $5$ etc.</p>

<p>We can, however, recursively define functions on vectors of all sizes, i.e., of all values of the index. For examples, here is the function that appends (adds to the end) an element to a vector.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Appending to a vector</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">_</span><span class="kt">:+</span><span class="kr">_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line"><span class="nf">a</span> <span class="kt">:+</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">a</span> <span class="ow">::</span> <span class="kt">[]</span>
</span><span class="line"><span class="nf">a</span> <span class="kt">:+</span> <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:+</span> <span class="n">xs</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Thus, vectors form an inductive type family indexed by natural numbers (and parametrized by A). As we remarked, the type for a given index is not an inductive type. Note that even in cases where we can meaningfully write down a recursion rule for the type at a fixed index, such a recursion rule does not hold, i.e., there is no recursion function using which we can translate pattern matching into function applicatio.</p>

<p><strong>Remark:</strong> From the point of view of programming languages, there is another sense in which indexing by natural numbers is different from parametrizing by types - the types we construct depend on <em>objects</em>, not just other types. Modern languages usually allow types to depend on other types (sometimes called generics), but most do not allow dependence on objects.</p>

<h3 id="a-dependent-function">A dependent function</h3>

<p>We shall now construct a dependent function <em>countdown</em> that maps a natural number $n$ to the list consisting of natural numbers from $n$ down to $0$. Thus the type of $countdown(n)$ is vectors of natural numbers of length $n+1$.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>countdown : a dependent function</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">countdown</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="err">ℕ</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line"><span class="nf">countdown</span> <span class="n">zero</span> <span class="ow">=</span> <span class="n">zero</span> <span class="ow">::</span> <span class="kt">[]</span>
</span><span class="line"><span class="nf">countdown</span> <span class="p">(</span><span class="n">succ</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">succ</span> <span class="n">m</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">countdown</span> <span class="n">m</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The definition in terms of pattern matching is similar to recursive definitions of functions. In terms of homotopy type theory, dependent functions on inductive types are constructed by applying a dependent function called the <em>induction function</em> to the data.</p>

<p>As mentioned earlier, the type of a dependent function is called the <em>product type</em> corresponding to the family of types with base the domain. For instance, the type of countdown is</p>

<script type="math/tex; mode=display">\prod\limits_{n : \Bbb{N}} Vec (\Bbb{N}) (n+1).</script>

<p>Except for universes (which we will keep in the background as far as possible), we have now seen all the type constructions - inductive types, functions and dependent functions.</p>

<h2 id="dependent-pairs">Dependent pairs</h2>

<p>Besides dependent products, the other fundamental dependent type associated to a type $A$ and a family of types $B: A \to \mathcal{U}$ is the <em>dependent sum type</em>, denoted $\Sigma_{a : A} B(a)$, whose elements are pairs $(a, b)$ with $a : A$ and $b : B(a)$. Like the pair type $A \times B$, this can be defined as an inductive type.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="err">Σ</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Type</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="p">[</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">]</span> <span class="kt">:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="kt">B</span> <span class="n">a</span><span class="p">)</span> <span class="err">→</span> <span class="err">Σ</span> <span class="kt">A</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="type-checking-with-dependent-types">Type checking with dependent types</h3>

<p>A principal use of types in programming is to avoid writing meaningless expressions, by ensuring that such expressions violate the rules for constructing objects and types. Dependent types are even better than this. For instance, consider the <em>zip</em> operation on vectors which associates to a vector of type $A$ with entries $a_i$ and a vector of type $B$ with entries $b_j$ a vector of type $A\times B$ with entries pairs $(a_i, b_i)$. This makes sense only when both vectors have the same length. Using dependent functions and types, we can define the function in such a way that it is defined only on pairs of vectors with the same length.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Componentwise operation on vectors</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">zip</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span>
</span><span class="line"><span class="nf">zip</span>  <span class="kt">[]</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class="line"><span class="nf">zip</span>  <span class="p">(</span><span class="n">x</span> <span class="ow">::</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span> <span class="ow">::</span> <span class="n">ys</span><span class="p">)</span>  <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="ow">::</span> <span class="p">(</span><span class="n">zip</span>  <span class="n">xs</span> <span class="n">ys</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Note that we could have used lists in place of vectors, but we would then have to give a definition that can lead to errors at runtime, or truncates perhaps giving unexpected values.</p>

<h2 id="exercise">Exercise:</h2>

<ul>
  <li>Define a function $vmap$ on vectors analogous to $map$ on lists.</li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/LogicTypesSpaces/blog/2015/01/21/recursion-functions-and-inductive-types/">Recursion Functions and Inductive Types</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>We have constructed various inductive types, and constructed functions on these types recursively. We have however not addressed the issue of what are valid definitions for inductive types and recursive functions. We now turn to these questions. The definition of inductive types we now consider is not the most general, but it includes all the examples so far.</p>

<h3 id="examples-recalled">Examples recalled</h3>

<p>Suppose now that we wish to define an inductive type $W$. We recall two previous types we have defined. For $W = \mathbb{N}$, we used the following  definition.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="err">ℕ</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">zero</span> <span class="kt">:</span> <span class="err">ℕ</span>
</span><span class="line">  <span class="n">succ</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Lists are a parametrized inductive type, which means that for each type $A$ we get a list of type $A$. We focus on the case where $A =\mathbb{N}$, so the inductive definition of $List\mathbb{N}=List\  \mathbb{N}$ becomes the following.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">List</span><span class="err">ℕ</span> <span class="kt">:</span> <span class="kt">Type</span> <span class="kr">where</span>
</span><span class="line">  <span class="kt">[]</span> <span class="kt">:</span> <span class="kt">List</span><span class="err">ℕ</span>
</span><span class="line">  <span class="kr">_</span><span class="ow">::</span><span class="kr">_</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">List</span><span class="err">ℕ</span> <span class="err">→</span> <span class="kt">List</span><span class="err">ℕ</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="constructors">Constructors.</h2>

<p>The inductive type $W$ is defined by constructors, which are curried functions that give an element in $W$, with the arguments possibly in $W$. In the above examples, the constructors have types:</p>

<ul>
  <li>For $W = \mathbb{N}$, $zero$ has type $W$ and $succ$ has type $W \to W$.</li>
  <li>For $W = List\mathbb{N}$, $[]$ has  type $W$ and $\_::\_$ has  type $\mathbb{N}\to W \to W$.</li>
</ul>

<p>It is clear how to generalize these. A constructor for a type $W$ can be:</p>

<ul>
  <li>$W$ itself (which we can think of as a function of no arguments giving $W$, i.e. $W = \to W$).</li>
  <li>obtained from a constructor type  $T =\dots \to W$ by mapping $W$ to this constructor type to get $W \to T = W \to \dots \to W$.</li>
  <li>obtained from a constructor type $T = \dots \to W$ by mapping a type $A$ not involving $W$ to this constructor type to get $A \to T = A \to \dots \to W$.</li>
</ul>

<p>We shall later see some other ways of building constructors. For the present, observe that all our examples so far, $\mathbb{N}$, $List A$, $Bool$, $A \times B$ and $A \oplus B$  are  all of this form. We shall next see what we mean by recursive definitions on such inductive types.</p>

<h2 id="recursive-definitions">Recursive definitions.</h2>

<p>We shall associate with an inductively defined type $W$ and another type $X$ a function $rec_{W, X}$ which has arguments the ingredients of a recursive definition and gives a function from $W$ to $X$. So the type of $rec_{W, X}$ is  of the form $\dots \to (W \to X)$.</p>

<p>First, consider the case when $W = \mathbb{N}$. A recursive function $f: W \to X$ is defined by specifying its value on $zero$ and on $succ(n)$ for $n \in \mathbb{N}$. These values in turn are determined by terms, whose types we call $D_{zero}$ and $D_{succ}$. In terms of these, the type of $rec_{\mathbb{N}, X}$ is thus $D_{zero} \to D_{succ} \to \mathbb{N}$.</p>

<p>The function $f$ is determined on $zero$ by simply specifying its image $f(zero) : X$, so $D_{zero}$ is just $X$. On the other hand, for $n : \mathbb{N}$, $f(succ(n))$ is a function of $n$ and $f(n)$. So specifying the image of $f$ on all numbers of the form $f(succ(n))$ amounts to giving a function $\mathbb{N} \to X \to X$, with the first argument to be applied to $n$ and the second to $f(n)$.</p>

<p>Thus, the recursion function of $\mathbb{N}$ has the type</p>

<script type="math/tex; mode=display">rec_{\mathbb{N}, X} : X \to (\mathbb{N} \to X \to X) \to (\mathbb{N} \to X)</script>

<p>Next, consider the case of lists of natural numbers. Again, we define a function $f$ recursively to a type $X$ in terms of the value on the result of each constructor. For the empty list, the value of $f$ is simply given by $f([]) : X$. On the other hand, for a list of the form $head :: tail$, the value of $f$ can be a function of $head$, $tail$ and $f(tail)$. Thus, we have a recursion function with the type</p>

<script type="math/tex; mode=display">rec_{List \mathbb{N}, X} : X \to (\mathbb{N} \to List \mathbb{N} \to X \to X) \to (List \mathbb{N} \to X)</script>

<p>It is easy to generalize these examples to an inductive type $W$ of the form we are considering. Namely, we associate to a constructor type $T$ a recursion data type $R_X(T)$ as follows:</p>

<ul>
  <li>if $T = W$, $R_X(T) = X$</li>
  <li>if $T = W \to T’$, $R_X(T) = W \to X \to R_X(T’)$</li>
  <li>if $T = A \to T’$ with $A$ independent of $W$, then $R_X(T) = A \to R_X(T’)$</li>
</ul>

<p>These rules tell us the type of the recursion functions. The recursion function satisfies certain <em>definitional equalities</em>, saying that it acts on the image of constructors as specified. For example, in the case of natural numbers, we get the identities:</p>

<ul>
  <li>$rec_{\mathbb{N}, X} (z) (f) (0) \equiv z$,</li>
  <li>$rec_{\mathbb{N}, X} (z) (f) (succ(n)) \equiv f (n) (rec_{\mathbb{N}, X} (z) (f) (n))$.</li>
</ul>

<p>In homotopy type theory, we view an inductive definition as introducing a type, constructor functions, a recursion function and certain definitional equalities. We shall see later the final ingredients of an inductive type definition, namely a so called <em>induction function</em> and corresponding definitional equalities.</p>

<p>In terms of Agda code, we can simply define the recursion functions. For instance, for natural numbers, we have:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">rec</span><span class="err">ℕ</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">X</span> <span class="kt">:</span> <span class="kt">Type</span><span class="p">}</span> <span class="err">→</span> <span class="kt">X</span> <span class="err">→</span> <span class="p">(</span><span class="err">ℕ</span> <span class="err">→</span> <span class="kt">X</span> <span class="err">→</span> <span class="kt">X</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="err">ℕ</span> <span class="err">→</span> <span class="kt">X</span><span class="p">)</span>
</span><span class="line"><span class="nf">rec</span><span class="err">ℕ</span> <span class="n">z</span> <span class="n">f</span> <span class="n">zero</span> <span class="ow">=</span> <span class="n">z</span>
</span><span class="line"><span class="nf">rec</span><span class="err">ℕ</span> <span class="n">z</span> <span class="n">f</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">n</span> <span class="p">(</span><span class="n">rec</span><span class="err">ℕ</span> <span class="n">z</span> <span class="n">f</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We shall construct the recursion functions in the other cases later. First, we shall see that we can make recursive definitions using the recursion function, without any pattern matching. In terms of Agda code, this means we need to use pattern matching only once - to construct the recursion function. In terms of homotopy type theory, all we use is that we have a recursion function of the appropriate type and that the corresponding definitional equalities hold.</p>

<h2 id="definitions-using-the-recursion-function">Definitions using the recursion function.</h2>

<p>We turn to examples of definitions using recursion functions. First we define the factorial. Note that in this definition $n!$ is just a variable name.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">_</span><span class="o">!</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="kr">_</span><span class="o">!</span> <span class="ow">=</span> <span class="n">rec</span><span class="err">ℕ</span> <span class="mi">1</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">n</span><span class="o">!</span> <span class="err">→</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="o">!</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Next, we define addition using the recursion function. This is a curried function $\_plus\_ : \mathbb{N} \to \mathbb{N} \to \mathbb{N}$, so $\_plus\_ (0) = 0\ plus\ \_$ is a function, namely the identity. Similarly $\_plus\_ (succ(n)) = (succ (n))\ plus\ \_$ is a function defined in terms of $n$ and $n\ plus\ \_$, where $n\ plus\ \_$ is the function <em>addition by $n$</em> (we use the variable name $nplus = \_ plus\_ (n)$). Clearly the following is a definition of addition (we have written this using nested lambdas for clarity).</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_plus_</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">_plus_</span> <span class="ow">=</span> <span class="n">rec</span><span class="err">ℕ</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="err">→</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">nplus</span> <span class="err">→</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="err">→</span> <span class="n">succ</span> <span class="p">(</span><span class="n">nplus</span> <span class="n">m</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Multiplication can be  defined similarly</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_times_</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class="line"><span class="nf">_times_</span> <span class="ow">=</span> <span class="n">rec</span><span class="err">ℕ</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="err">→</span> <span class="mi">0</span><span class="p">)(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">ntimes</span> <span class="err">→</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="err">→</span> <span class="p">(</span><span class="n">ntimes</span> <span class="n">m</span><span class="p">)</span> <span class="n">plus</span> <span class="n">m</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="foundations-so-far">Foundations so far.</h2>

<p>As you can observe, we have now defined functions purely in terms of lambdas and recursion function. Thus, we now have clear foundation rules. Namely,</p>

<ul>
  <li>We have (so far) two ways of constructing types - inductive types and function types.</li>
  <li>Terms can be constructed by applying a function $f: A \to B$ to a term $a : A$. We make the judgment $f(a) : B$.  </li>
  <li>Terms of function types are constructed using lambdas. A $\lambda$-term $A \to B$ is of the form $\lambda a \mapsto b$ where $b$ is an expression of type $b$, which can involve the variable (term)
$a : A$ and is otherwise built using the usual rules for forming terms.</li>
  <li>An inductive type $W$ is specified by specifying the types of constructors. The type of a constructor is built from $W$ in certain specified ways.</li>
  <li>When defining an inductive type, we define constructors as terms of the specified type.</li>
  <li>For an inductive type $W$ and a type $X$, we obtain a recursion function $rec_{W, X}$, whose type is determined in terms of the constructors of $W$. We have certain <em>computation</em> rules giving definitional equalities for the action of a recursively defined function on the image of a constructor.</li>
</ul>

<p>We need a few more rules of a similar nature, mainly concerned with extending rules involving functions to so called <em>dependent functions</em>. Our next goal is to introduce dependent functions.</p>

<h2 id="exercise">Exercise</h2>

<ul>
  <li>Define the recursion functions $recBool$ on Booleans.</li>
  <li>Define the recursion function $recList(A)$ as a function of $A : Type$.</li>
  <li>Define $not$, $\_ \&amp; \_$  and $\_contains&#92;_$ in terms of the above recursion functions without using any pattern matching.</li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/LogicTypesSpaces/blog/2015/01/20/a-program/">A Program : Lattice Points in a Circle</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>We now give a program (i.e., a function) that, given a natural number $n$, lists all points in the plane with co-ordinates natural numbers, which are contained in the circle of radius $n$. This illustrates how we can implement a combination of nested loops and conditions using <em>map</em>, <em>flatMap</em> and <em>filter</em>.</p>

<p>We first define a function $leq$, denoting less than or equal to, for natural number. We have reserved $\leq$ for something nicer. This is a recursive definition.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_leq_</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Bool</span>
</span><span class="line"><span class="nf">zero</span> <span class="n">leq</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">true</span>
</span><span class="line"><span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="n">leq</span> <span class="n">zero</span> <span class="ow">=</span> <span class="n">false</span>
</span><span class="line"><span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="n">leq</span> <span class="p">(</span><span class="n">succ</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="n">n</span> <span class="n">leq</span> <span class="n">m</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can now construct the function we promised. For each $a \in \mathbb{N}$, we can define a function associating to it a list by filtering $b\in \mathbb{N}$ by requiring the pair $(a , b)$ to lie in the circle, and then map to the pair $(a, b)$. We flatMap using this list-valued function.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">points</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">List</span> <span class="p">(</span><span class="err">ℕ</span> <span class="err">×</span> <span class="err">ℕ</span><span class="p">)</span>
</span><span class="line"><span class="nf">points</span> <span class="n">n</span> <span class="ow">=</span> <span class="p">(</span><span class="n">upto</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">))</span> <span class="n">flatMap</span> <span class="p">(</span><span class="err">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="p">((</span><span class="n">upto</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">))</span> <span class="n">filter</span> <span class="p">(</span><span class="err">λ</span> <span class="n">b</span> <span class="err">→</span> <span class="p">((</span><span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">))</span> <span class="n">leq</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span><span class="n">points</span> <span class="p">))</span> <span class="n">map</span> <span class="p">(</span><span class="err">λ</span> <span class="n">b</span> <span class="err">→</span> <span class="p">[</span> <span class="n">a</span> <span class="p">,</span> <span class="n">b</span> <span class="p">]))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We have used <em>map</em>, <em>flatMap</em> and <em>filter</em> to replace nested loops and control statements (<em>if</em> in this case) in older programming languages. In imperative code we would have started with an empty list, used a loop for $a$, an inner one for $b$ and added to the list pairs that satisfy the condition of lying in the circle.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="">&larr; Older</a>
    
    <a href="/LogicTypesSpaces/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/LogicTypesSpaces/blog/2015/03/30/equivalence-of-types/">Equivalence of Types</a>
      </li>
    
      <li class="post">
        <a href="/LogicTypesSpaces/blog/2015/03/30/homotopy-type-theory/">Homotopy Type Theory</a>
      </li>
    
      <li class="post">
        <a href="/LogicTypesSpaces/blog/2015/02/09/exercises-for-midterm/">Exercises for Midterm</a>
      </li>
    
      <li class="post">
        <a href="/LogicTypesSpaces/blog/2015/02/02/logic-from-types/">Logic From Types</a>
      </li>
    
      <li class="post">
        <a href="/LogicTypesSpaces/blog/2015/01/30/fin-type-family/">Fin Type Family</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/siddhartha-gadgil">@siddhartha-gadgil</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'siddhartha-gadgil',
            count: 4,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/LogicTypesSpaces/javascripts/github.js" type="text/javascript"> </script>
</section>



<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/+SiddharthaGadgil?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Siddhartha Gadgil -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'logictypesandspaces';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
